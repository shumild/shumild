<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shumild.github.io</id>
    <title>shumild</title>
    <updated>2022-02-04T13:44:18.713Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shumild.github.io"/>
    <link rel="self" href="https://shumild.github.io/atom.xml"/>
    <subtitle>这是一个正在学习中的大三菜鸟</subtitle>
    <logo>https://shumild.github.io/images/avatar.png</logo>
    <icon>https://shumild.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, shumild</rights>
    <entry>
        <title type="html"><![CDATA[HTTP协议]]></title>
        <id>https://shumild.github.io/post/http-xie-yi/</id>
        <link href="https://shumild.github.io/post/http-xie-yi/">
        </link>
        <updated>2022-01-22T13:23:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-协议">HTTP 协议</h1>
<h2 id="什么是通信">什么是通信</h2>
<p>通信，就是<strong>信息的传递和交换</strong>。</p>
<p>通信三要素：</p>
<ul>
<li>
<p>通信的主体</p>
</li>
<li>
<p>通信的内容</p>
</li>
<li>
<p>通信的方式</p>
</li>
</ul>
<h3 id="现实生活中的通信">现实生活中的通信</h3>
<p>案例：<strong>张三</strong>要把自己考上大学的好消息<strong>写信</strong>告诉自己的好朋友<strong>李四</strong>。</p>
<p>其中：</p>
<p>​			通信的<strong>主体</strong>是张三和李四。</p>
<p>​			通信的<strong>内容</strong>是考上大学。</p>
<p>​			通信的<strong>方式</strong>是<strong>写信</strong>。</p>
<h3 id="互联网中的通信">互联网中的通信</h3>
<p>案例：<strong>服务器</strong>把大学的简介通过<strong>响应</strong>的方式发送给<strong>客户端浏览器</strong>。</p>
<p>其中：</p>
<p>​			通信的<strong>主体</strong>是服务器和客户端浏览器。</p>
<p>​			通信的<strong>内容</strong>是大学的简介。</p>
<p>​			通信的<strong>方式</strong>是<strong>响应</strong>。</p>
<h2 id="什么是通信协议">什么是通信协议</h2>
<p><strong>通信协议</strong>（Communication Protocol）是指通信的双方完成通信所<strong>必须遵守</strong>的<strong>规则和约定</strong>。</p>
<p>通俗的理解：通信双方<strong>采用约定好的格式</strong>来发送和接收消息，这种<strong>事先约定好的通信格式</strong>，就叫做通信协议。</p>
<h3 id="生活中的通信协议">生活中的通信协议</h3>
<p><strong>张三</strong>与李四采用<strong>写信</strong>的方式进行通信，在填写信封时，写信的双方需要<strong>遵守固定的规则</strong>。<strong>信封的填写规则</strong>就是一种通信协议。</p>
<figure data-type="image" tabindex="1"><img src="https://shumild.github.io/post-images/1643808606596.png" alt="" loading="lazy"></figure>
<h3 id="互联网中的通信协议">互联网中的通信协议</h3>
<p>客户端与服务器之间要实现<strong>网页内容</strong>的传输，则通信的双方必须遵守<strong>网页内容的传输协议</strong>。</p>
<p><strong>网页内容</strong>又叫做<strong>超文本</strong>，因此<strong>网页内容的传输协议</strong>又叫做<strong>超文本传输协议</strong>（HyperText Transfer Protocol），简称 <strong>HTTP</strong> <strong>协议</strong>。</p>
<h2 id="http">HTTP</h2>
<h3 id="什么是-http-协议">什么是 HTTP 协议</h3>
<p><strong>HTTP</strong> <strong>协议</strong>即超文本传送协议 (<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。</p>
<p>例如：</p>
<ul>
<li>
<p><strong>客户端</strong>要以HTTP协议要求的格式把数据<strong>提交</strong>到<strong>服务器</strong></p>
</li>
<li>
<p><strong>服务器</strong>要以HTTP协议要求的格式把内容<strong>响应</strong>给<strong>客户端</strong></p>
</li>
</ul>
<h3 id="http-协议的交互模型">HTTP 协议的交互模型</h3>
<p>HTTP 协议采用了 <strong>请求/响应</strong> 的交互模型。</p>
<figure data-type="image" tabindex="2"><img src="https://shumild.github.io/post-images/1643808586191.png" alt="" loading="lazy"></figure>
<h1 id="http-请求消息">HTTP 请求消息</h1>
<h2 id="什么是-http-请求消息">什么是 HTTP 请求消息</h2>
<p>由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，<strong>客户端发起</strong>的请求叫做 <strong>HTTP</strong> <strong>请求</strong>，<strong>客户端发送到服务器</strong>的消息，叫做 <strong>HTTP</strong> <strong>请求消息</strong>。</p>
<blockquote>
<p><strong>注意</strong>：HTTP <strong>请求消息</strong>又叫做 HTTP <strong>请求报文</strong>。</p>
</blockquote>
<h2 id="http-请求消息的组成部分">HTTP 请求消息的组成部分</h2>
<p>HTTP 请求消息由<strong>请求行</strong>（request line）、<strong>请求头部</strong>（ header ） 、<strong>空行</strong> 和 <strong>请求体</strong> 4 个部分组成。</p>
<figure data-type="image" tabindex="3"><img src="https://shumild.github.io/post-images/1643808560103.png" alt="" loading="lazy"></figure>
<h3 id="请求行">请求行</h3>
<p><strong>请求行</strong>由<strong>请求方式</strong>、<strong>URL</strong> 和 <strong>HTTP 协议版本</strong> 3 个部分组成，他们之间使用空格隔开。</p>
<figure data-type="image" tabindex="4"><img src="https://shumild.github.io/post-images/1643808543515.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://shumild.github.io/post-images/1643808529261.png" alt="" loading="lazy"></figure>
<h3 id="请求头部">请求头部</h3>
<p><strong>请求头部</strong>用来描述<strong>客户端的基本信息</strong>，从而把<strong>客户端相关的信息</strong>告知服务器。比如：<strong>User-Agent</strong> 用来说明当前是什么类型的浏览器；<strong>Content-Type</strong> 用来描述发送到服务器的数据格式；<strong>Accept</strong> 用来描述客户端能够接收什么类型的返回内容；<strong>Accept-Language</strong> 用来描述客户端期望接收哪种人类语言的文本内容。</p>
<p>请求头部由多行 <strong>键/值对</strong> 组成，每行的键和值之间用英文的冒号分隔。</p>
<figure data-type="image" tabindex="6"><img src="https://shumild.github.io/post-images/1643808510800.png" alt="" loading="lazy"></figure>
<h4 id="常见的请求头字段">常见的请求头字段</h4>
<table>
<thead>
<tr>
<th><strong>头部字段</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>要请求的服务器域名</td>
</tr>
<tr>
<td>Connection</td>
<td>客户端与服务器的连接方式(close  或  keepalive)</td>
</tr>
<tr>
<td>Content-Length</td>
<td>用来描述请求体的大小</td>
</tr>
<tr>
<td>Accept</td>
<td>客户端可识别的响应内容类型列表</td>
</tr>
<tr>
<td>User-Agent</td>
<td>产生请求的浏览器类型</td>
</tr>
<tr>
<td>Content-Type</td>
<td>客户端告诉服务器实际发送的数据类型</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>客户端可接收的内容压缩编码形式</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>用户期望获得的自然语言的优先顺序</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="7"><img src="https://shumild.github.io/post-images/1643808494359.png" alt="" loading="lazy"></figure>
<p>关于更多请求头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</p>
<h3 id="空行">空行</h3>
<p>最后一个请求头字段的后面是一个<strong>空行</strong>，通知服务器<strong>请求头部至此结束</strong>。</p>
<p>请求消息中的空行，用来分隔<strong>请求头部</strong>与<strong>请求体</strong>。</p>
<figure data-type="image" tabindex="8"><img src="https://shumild.github.io/post-images/1643808478328.png" alt="" loading="lazy"></figure>
<h3 id="请求体">请求体</h3>
<p>请求体中存放的，是要通过 <strong>POST 方式</strong>提交到服务器的数据。</p>
<figure data-type="image" tabindex="9"><img src="https://shumild.github.io/post-images/1643808462716.png" alt="" loading="lazy"></figure>
<blockquote>
<p><strong>注意</strong>：只有 POST 请求才有请求体，GET 请求没有请求体！</p>
</blockquote>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="10"><img src="https://shumild.github.io/post-images/1643808447957.png" alt="" loading="lazy"></figure>
<h1 id="http-响应消息">HTTP 响应消息</h1>
<h2 id="什么是-http-响应消息">什么是 HTTP 响应消息</h2>
<p><strong>响应消息</strong>就是<strong>服务器响应给客户端</strong>的消息内容，也叫作响应报文。</p>
<h2 id="http-响应消息的组成部分">HTTP 响应消息的组成部分</h2>
<p>HTTP响应消息由<strong>状态行</strong>、<strong>响应头部</strong>、<strong>空行</strong> 和 <strong>响应体</strong> 4 个部分组成，如下图所示：</p>
<figure data-type="image" tabindex="11"><img src="https://shumild.github.io/post-images/1643808430624.png" alt="" loading="lazy"></figure>
<h3 id="状态行">状态行</h3>
<p><strong>状态行</strong>由 <strong>HTTP 协议版本</strong>、<strong>状态码</strong>和<strong>状态码的描述文本</strong> 3 个部分组成，他们之间使用空格隔开。</p>
<figure data-type="image" tabindex="12"><img src="https://shumild.github.io/post-images/1643808408835.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://shumild.github.io/post-images/1643808394273.png" alt="" loading="lazy"></figure>
<h3 id="响应头部">响应头部</h3>
<p><strong>响应头部</strong>用来描述<strong>服务器的基本信息</strong>。响应头部由多行 <strong>键/值对</strong> 组成，每行的键和值之间用英文的冒号分隔。</p>
<figure data-type="image" tabindex="14"><img src="https://shumild.github.io/post-images/1643808374980.png" alt="" loading="lazy"></figure>
<h4 id="常见的响应头字段">常见的响应头字段</h4>
<figure data-type="image" tabindex="15"><img src="https://shumild.github.io/post-images/1643808361441.png" alt="" loading="lazy"></figure>
<p>关于更多响应头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</p>
<h3 id="空行-2">空行</h3>
<p>在最后一个响应头部字段结束之后，会紧跟一个<strong>空行</strong>，用来通知客户端<strong>响应头部至此结束</strong>。</p>
<p>响应消息中的空行，用来分隔<strong>响应头部</strong>与<strong>响应体</strong>。</p>
<figure data-type="image" tabindex="16"><img src="https://shumild.github.io/post-images/1643808344889.png" alt="" loading="lazy"></figure>
<h3 id="响应体">响应体</h3>
<p>响应体中存放的，是服务器响应给客户端的资源内容。</p>
<p><img src="https://shumild.github.io/post-images/1643808327233.png" alt="" loading="lazy">)</p>
<figure data-type="image" tabindex="17"><img src="https://shumild.github.io/post-images/1643808295895.png" alt="" loading="lazy"></figure>
<h3 id="总结-2">总结</h3>
<figure data-type="image" tabindex="18"><img src="https://shumild.github.io/post-images/1643808270515.png" alt="" loading="lazy"></figure>
<h1 id="http-请求方法">HTTP 请求方法</h1>
<h2 id="什么是-http-请求方法">什么是 HTTP 请求方法</h2>
<p>HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明<strong>要对服务器上的资源执行的操作</strong>。最常用的请求方法是 GET 和 POST。</p>
<h2 id="http-的请求方法">HTTP 的请求方法</h2>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>GET</strong></td>
<td>(<strong>查询</strong>)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。</td>
</tr>
<tr>
<td>2</td>
<td><strong>POST</strong></td>
<td>(<strong>新增</strong>)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。</td>
</tr>
<tr>
<td>3</td>
<td><strong>PUT</strong></td>
<td>(<strong>修改</strong>)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。</td>
</tr>
<tr>
<td>4</td>
<td><strong>DELETE</strong></td>
<td>(<strong>删除</strong>)请求服务器删除指定的资源。</td>
</tr>
<tr>
<td>5</td>
<td>HEAD</td>
<td>HEAD  方法请求一个与 GET 请求的响应相同的响应，但没有响应体。</td>
</tr>
<tr>
<td>6</td>
<td>OPTIONS</td>
<td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td>
</tr>
<tr>
<td>7</td>
<td>CONNECT</td>
<td>建立一个到由目标资源标识的服务器的隧道。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。</td>
</tr>
<tr>
<td>9</td>
<td>PATCH</td>
<td>是对  PUT 方法的补充，用来对已知资源进行局部更新。</td>
</tr>
</tbody>
</table>
<h1 id="http-响应状态码">HTTP 响应状态码</h1>
<h2 id="什么是-http-响应状态码">什么是 HTTP 响应状态码</h2>
<p><strong>HTTP</strong> <strong>响应状态码</strong>（HTTP Status Code），也属于 HTTP 协议的一部分，<strong>用来标识响应的状态</strong>。</p>
<p>响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。</p>
<figure data-type="image" tabindex="19"><img src="https://shumild.github.io/post-images/1643808252843.png" alt="" loading="lazy"></figure>
<h2 id="http-响应状态码的组成及分类">HTTP 响应状态码的组成及分类</h2>
<p>HTTP 状态码由<strong>三个十进制数字</strong>组成，<strong>第一个十进制数字</strong>定义了<strong>状态码的类型</strong>，后两个数字用来对状态码进行细分。</p>
<p>HTTP 状态码共分为 5 种类型：</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>分类描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1**</td>
<td><strong>信息</strong>，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到  1**  类型的状态码）</td>
</tr>
<tr>
<td>2**</td>
<td><strong>成功</strong>，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td><strong>重定向</strong>，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td><strong>客户端错误</strong>，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td><strong>服务器错误</strong>，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p>完整的 HTTP 响应状态码，可以参考 MDN 官方文档 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</p>
<h3 id="2-成功相关的响应状态码">2** 成功相关的响应状态码</h3>
<p>2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于  GET 与 POST  请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源，通常用于  POST 或 PUT  请求</td>
</tr>
</tbody>
</table>
<h3 id="3-重定向相关的响应状态码">3** 重定向相关的响应状态码</h3>
<p>3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>301</td>
<td>Moved  Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替  。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。</td>
</tr>
<tr>
<td>304</td>
<td>Not  Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td>
</tr>
</tbody>
</table>
<h3 id="4-客户端错误相关的响应状态码">4** 客户端错误相关的响应状态码</h3>
<p>4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>Bad  Request</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>当前请求需要用户验证。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器已经理解请求，但是拒绝执行它。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
<tr>
<td>408</td>
<td>Request  Timeout</td>
<td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td>
</tr>
</tbody>
</table>
<h3 id="5-服务器错误相关的响应状态码">5** 服务器错误相关的响应状态码</h3>
<p>5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的 5** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>Internal  Server Error</td>
<td>服务器内部错误，无法完成请求。</td>
</tr>
<tr>
<td>501</td>
<td>Not  Implemented</td>
<td>服务器不支持该请求方法，无法完成请求。只有  GET 和 HEAD  请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501。</td>
</tr>
<tr>
<td>503</td>
<td>Service  Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跨域和JSONP]]></title>
        <id>https://shumild.github.io/post/kua-yu-he-jsonp/</id>
        <link href="https://shumild.github.io/post/kua-yu-he-jsonp/">
        </link>
        <updated>2022-01-21T13:21:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="同源策略和跨域">同源策略和跨域</h1>
<h2 id="同源策略">同源策略</h2>
<h3 id="什么是同源">什么是同源</h3>
<p>如果两个页面的<strong>协议</strong>，域名和<strong>端口</strong>都相同，则两个页面具有<strong>相同的源</strong>。</p>
<p>例如，下表给出了相对于 http://www.text.com/index.html 页面的同源检测：</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>是否同源</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>http://www.text.com/other.html</td>
<td>是</td>
<td>同源（协议、域名、端口相同）</td>
</tr>
<tr>
<td>https://www.text.com/about.html</td>
<td>否</td>
<td>协议不同（ <strong>http</strong> 与 <strong>https</strong> ）</td>
</tr>
<tr>
<td>http://blog.text.com/movie.html</td>
<td>否</td>
<td>域名不同（<strong>www.text.com</strong> 与 <strong>blog.text.com</strong> )</td>
</tr>
<tr>
<td>http://www.text.com:7001/home.html</td>
<td>否</td>
<td>端口不同（默认的 <strong>80</strong> 端口与 <strong>7001</strong> 端口）</td>
</tr>
<tr>
<td>http://www.text.com:80/main.html</td>
<td>是</td>
<td>同源（协议、域名、端口相同）</td>
</tr>
</tbody>
</table>
<h3 id="什么是同源策略">什么是同源策略</h3>
<p><strong>同源策略</strong>（英文全称 Same origin policy ）是<strong>浏览器</strong>提供的一个<strong>安全功能</strong>。</p>
<p>MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和<strong>非同源的</strong>网站 C 之间，进行资源的交互，例如：</p>
<ol>
<li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</li>
<li>无法接触非同源网页的 DOM。</li>
<li>无法向非同源地址发送 Ajax 请求。</li>
</ol>
<h2 id="跨域">跨域</h2>
<h3 id="什么是跨域">什么是跨域</h3>
<p><strong>同源</strong>指的是两个 URL 的协议、域名、端口一致，反之，则是<strong>跨域</strong>。</p>
<p>出现跨域的根本原因：<strong>浏览器的同源策略</strong>不允许非同源的 URL 之间进行资源的交互。</p>
<p>网页：http://www.test.com/index.html</p>
<p>接口：http://www.api.com/userlist</p>
<h3 id="浏览器对跨域请求的拦截">浏览器对跨域请求的拦截</h3>
<figure data-type="image" tabindex="1"><img src="https://shumild.github.io/post-images/1643808143549.png" alt="" loading="lazy"></figure>
<blockquote>
<p><strong>注意</strong>：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！</p>
</blockquote>
<h3 id="如何实现跨域数据请求">如何实现跨域数据请求</h3>
<p>现如今，实现跨域数据请求，最主要的两种解决方案，分别是 <strong>JSONP</strong> 和 <strong>CORS</strong>。</p>
<p>JSONP：出现的早，兼容性好（兼容低版本 IE ）。是前端程序员为了解决跨域问题，被迫想出来的一种<strong>临时解决方案</strong>。缺点是<strong>只支持 GET 请求</strong>，不支持 POST 请求。</p>
<p>CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。</p>
<h1 id="jsonp">JSONP</h1>
<h2 id="什么是-jsonp">什么是 JSONP</h2>
<p>JSONP（JSON with Padding）是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p>
<h2 id="jsonp-的实现原理">JSONP 的实现原理</h2>
<p>由于<strong>浏览器同源策略</strong>的限制，网页中<strong>无法通过 Ajax 请求非同源的接口数据</strong>。但是 <code>&lt;script&gt;</code> 标签不受浏览器同源策略的影响，可以通过 src 属性，请求非同源的 js 脚本</p>
<p>因此，JSONP 的实现原理，就是通过 <script> 标签的 src 属性，请求跨域的数据接口，并通过<strong>函数调用</strong>的形式，接收跨域接口响应回来的数据。</p>
<h2 id="自己实现一个简单的-jsonp">自己实现一个简单的 JSONP</h2>
<p>定义一个 success 回调函数：</p>
<pre><code class="language-html">&lt;script&gt;
   function success(data) {
     console.log('获取到了data数据：')
     console.log(data)
   }
&lt;/script&gt;
</code></pre>
<p>通过 <code>&lt;script&gt;</code> 标签，请求接口数据：</p>
<pre><code class="language-html">&lt;script src=&quot;http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&amp;name=zs&amp;age=20&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="jsonp-的缺点">JSONP 的缺点</h2>
<p>由于 JSONP 是通过 <code>&lt;script&gt;</code> 标签的 src 属性，来实现跨域数据获取的，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。</p>
<blockquote>
<p><strong>注意</strong>：<strong>JSONP</strong> <strong>和</strong> <strong>Ajax</strong> <strong>之间没有任何关系</strong>，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。</p>
</blockquote>
<h2 id="jquery-中的-jsonp">jQuery 中的 JSONP</h2>
<p>jQuery 提供的 <code>$.ajax()</code> 函数，除了可以发起真正的 Ajax 数据请求之外，还能够发起 JSONP 数据请求，例如：</p>
<pre><code class="language-javascript">$.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20',
    // 如果要使用 $.ajax() 发起 JSONP 请求，必须指定 datatype 为 jsonp
    dataType: 'jsonp',
    success: function(res) {
       console.log(res)
    }
})
</code></pre>
<p>默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback=jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称。</p>
<h2 id="自定义参数及回调函数名称">自定义参数及回调函数名称</h2>
<p>在使用 jQuery 发起 JSONP 请求时，如果想要自定义 JSONP 的<strong>参数</strong>以及<strong>回调函数名称</strong>，可以通过如下两个参数来指定：</p>
<pre><code class="language-javascript">$.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20',
    dataType: 'jsonp',
    // 发送到服务端的参数名称，默认值为 callback
    jsonp: 'callback',
    // 自定义的回调函数名称，默认值为 jQueryxxx 格式
    jsonpCallback: 'abc',
    success: function(res) {
       console.log(res)
    }
})
</code></pre>
<h2 id="jquery-中-jsonp-的实现过程">jQuery 中 JSONP 的实现过程</h2>
<p>jQuery 中的 JSONP，也是通过 <code>&lt;script&gt;</code> 标签的 src 属性实现跨域数据访问的，只不过，jQuery 采用的是<strong>动态创建和移除</strong> <code>&lt;script&gt;</code> <strong>标签</strong>的方式，来发起 JSONP 数据请求。</p>
<ul>
<li>
<p>在发起 JSONP 请求的时候，动态向 <code>&lt;header&gt;</code> 中 append 一个 <code>&lt;script&gt;</code> 标签。</p>
</li>
<li>
<p>在 JSONP 请求成功以后，动态从 <code>&lt;header&gt;</code> 中移除刚才 append 进去的 <code>&lt;script&gt;</code> 标签。</p>
</li>
</ul>
<h1 id="防抖">防抖</h1>
<h2 id="什么是防抖">什么是防抖</h2>
<p><strong>防抖策略</strong>（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</p>
<figure data-type="image" tabindex="2"><img src="https://shumild.github.io/post-images/1643808116563.png" alt="" loading="lazy"></figure>
<h2 id="防抖的应用场景">防抖的应用场景</h2>
<p>用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源。</p>
<h2 id="实现输入框的防抖">实现输入框的防抖</h2>
<pre><code class="language-javascript">var timer = null                    // 1. 防抖动的 timer

function debounceSearch(keywords) { // 2. 定义防抖的函数
    timer = setTimeout(function() {
    // 发起 JSONP 请求
    getSuggestList(keywords)
    }, 500)
}

$('#ipt').on('keyup', function() {  // 3. 在触发 keyup 事件时，立即清空 timer
    clearTimeout(timer)
    // ...省略其他代码
    debounceSearch(keywords)
})
</code></pre>
<h2 id="缓存搜索的建议列表">缓存搜索的建议列表</h2>
<h3 id="定义全局缓存对象">定义全局缓存对象</h3>
<pre><code class="language-javascript">// 缓存对象
var cacheObj = {}
</code></pre>
<h3 id="将搜索结果保存到缓存对象中">将搜索结果保存到缓存对象中</h3>
<pre><code class="language-javascript">// 渲染建议列表
function renderSuggestList(res) {
    // ...省略其他代码
    // 将搜索的结果，添加到缓存对象中
    var k = $('#ipt').val().trim()
    cacheObj[k] = res
}
</code></pre>
<h3 id="优先从缓存中获取搜索建议">优先从缓存中获取搜索建议</h3>
<pre><code class="language-javascript">// 监听文本框的 keyup 事件
$('#ipt').on('keyup', function() {
    // ...省略其他代码

    // 优先从缓存中获取搜索建议
    if (cacheObj[keywords]) {
       return renderSuggestList(cacheObj[keywords])
    }
    // 获取搜索建议列表
    debounceSearch(keywords)
})
</code></pre>
<h1 id="节流">节流</h1>
<h2 id="什么是节流">什么是节流</h2>
<p><strong>节流策略</strong>（throttle），顾名思义，可以减少一段时间内事件的触发频率。</p>
<figure data-type="image" tabindex="3"><img src="https://shumild.github.io/post-images/1643808093769.png" alt="" loading="lazy"></figure>
<h2 id="节流的应用场景">节流的应用场景</h2>
<ol>
<li>
<p>鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次。</p>
</li>
<li>
<p>懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源。</p>
</li>
</ol>
<h2 id="节流阀的概念">节流阀的概念</h2>
<p>高铁卫生间是否被占用，由红绿灯控制，<strong>红灯</strong>表示被占用，<strong>绿灯</strong>表示<strong>可使用</strong>。</p>
<p>假设每个人上卫生间都需要花费<strong>5分钟</strong>，则<strong>五分钟之内</strong>，被占用的卫生间无法被其他人使用。</p>
<p>上一个人使用完毕后，需要将红灯<strong>重置</strong>为绿灯，表示下一个人可以使用卫生间。</p>
<p>下一个人在上卫生间之前，需要<strong>先判断控制灯</strong>是否为绿色，来知晓能否上卫生间。</p>
<p>节流阀为<strong>空</strong>，表示<strong>可以执行下次操作</strong>；<strong>不为空</strong>，表示<strong>不能执行下次操作</strong>。</p>
<p>当前操作执行完，必须将节流阀<strong>重置</strong>为空，表示可以执行下次操作了。</p>
<p>每次执行操作前，必须<strong>先判断节流阀是否为空</strong>。</p>
<h2 id="鼠标跟随效果">鼠标跟随效果</h2>
<h3 id="渲染-ui-结构">渲染 UI 结构</h3>
<pre><code class="language-html">&lt;!-- UI 结构 --&gt;
&lt;img src=&quot;./assets/angel.gif&quot; alt=&quot;&quot; id=&quot;angel&quot; /&gt;

/* CSS 样式 */
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
}#angel {
  position: absolute;
}

</code></pre>
<h3 id="不使用节流时实现鼠标跟随效果">不使用节流时实现鼠标跟随效果</h3>
<pre><code class="language-javascript">$(function() {
   // 获取图片元素
   var angel = $('#angel')
   // 监听文档的 mousemove 事件
   $(document).on('mousemove', function(e) {      // 设置图片的位置
      $(angel).css('left', e.pageX + 'px').css('top', e.pageY + 'px')
   })
})
</code></pre>
<h3 id="使用节流优化鼠标跟随效果">使用节流优化鼠标跟随效果</h3>
<pre><code class="language-javascript">$(function() {
  var angel = $('#angel')
  var timer = null // 1.预定义一个 timer 节流阀
  $(document).on('mousemove', function(e) {
    if (timer) { return } // 3.判断节流阀是否为空，如果不为空，则证明距离上次执行间隔不足16毫秒
    timer = setTimeout(function() {
      $(angel).css('left', e.pageX + 'px').css('top', e.pageY + 'px')
      timer = null // 2.当设置了鼠标跟随效果后，清空 timer 节流阀，方便下次开启延时器
    }, 16)
  })
})
</code></pre>
<blockquote>
<p>防抖与节流的区别</p>
<p><strong>防抖</strong>：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面 N 多次的触发都会被忽略！</p>
<p><strong>节流</strong>：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ajax加强]]></title>
        <id>https://shumild.github.io/post/ajax-jia-qiang/</id>
        <link href="https://shumild.github.io/post/ajax-jia-qiang/">
        </link>
        <updated>2022-01-20T13:10:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="xmlhttprequest-的基本使用">XMLHttpRequest 的基本使用</h1>
<h2 id="什么是-xmlhttprequest">什么是 XMLHttpRequest</h2>
<p>XMLHttpRequest（简称xhr）是浏览器提供的JavaScript对象，通过它，可以请求服务器上的数据资源。</p>
<p>jQuery中的Ajax函数，就是基于xhr对象封装出来的。</p>
<h2 id="使用xhr发起get请求">使用xhr发起GET请求</h2>
<ol>
<li>创建<code>xhr</code>对象</li>
<li>调用<code>xhr.open()</code>函数</li>
<li>调用<code>xhr.send()</code>函数</li>
<li>监听<code>xhr.onreadystatechange</code>事件</li>
</ol>
<pre><code class="language-javascript">//1. 创建xhr对象 
var xhr = newXMLHttpRequest()
//2. 调用xhr.open()函数
xhr.open('GET','http://www.liulongbin.top:3006/api/getbooks')
//3. 调用xhr.send()函数
xhr.send()
//4. 监听xhr.onreadystatechange事件
xhr.onreadystatechange = function(){
    //4.1 监听xhr对象的请求状态 readyState;与服务器响应状态 status
    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
        //4.2 打印服务器响应回来的数据
        console.log(xhr.respanseText)
    }
}
</code></pre>
<h2 id="了解xhr对象的readystate属性">了解xhr对象的readyState属性</h2>
<p>XMLHttpRequest 对象的readyState属性，用来表示<strong>当前Ajax请求所处的状态</strong>。每个Ajax请求必然处于以下状态中的一个：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>UNSENT</td>
<td>XMLHttpRequest对象已被创建，但尚未调用open方法。</td>
</tr>
<tr>
<td>1</td>
<td>OPENED</td>
<td>open()方法已经被调用。</td>
</tr>
<tr>
<td>2</td>
<td>HEADERS_RECEIVED</td>
<td>send()方法已经被调用，响应头也已经被接收。</td>
</tr>
<tr>
<td>3</td>
<td>LOADING</td>
<td>数据接收中，此时response属性中已经包含部分数据。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>DONE</strong></td>
<td><strong>Ajax请求完成</strong>，这意味着数据传输已经彻底<strong>完成</strong>或<strong>失败</strong>。</td>
</tr>
</tbody>
</table>
<h2 id="使用xhr发起带参数的get请求">使用xhr发起带参数的GET请求</h2>
<p>使用xhr对象发起带参数的GET请求时，只需在调用xhr.open期间，为URL地址指定参数即可：</p>
<pre><code class="language-javascript">//...
xhr.open('GET','http://www.liulongbin.top:3006/api/getbooks?id=1')
//...
</code></pre>
<p>这种在URL地址后面拼接的参数，叫做<strong>查询字符串</strong>。</p>
<h2 id="查询字符串">查询字符串</h2>
<h3 id="什么是查询字符串">什么是查询字符串</h3>
<p>定义：查询字符串（URL参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量）。</p>
<p>格式：将英文的 <code>?</code> 放在URL的末尾，再加上 <code>参数=值</code>，想加上多个参数的话，使用 <code>&amp;</code> 符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到 URL 中。</p>
<pre><code class="language-javascript">//不带参数的URL地址
http://www.liulongbin.top:3006/api/getbooks?
//带有一个参数的URL地址
http://www.liulongbin.top:3006/api/getbooks?id=1
//带有两个参数的URL地址
http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=西游记
</code></pre>
<h3 id="get请求携带参数的本质">GET请求携带参数的本质</h3>
<p>无论使用<code>$.ajax()</code>,还是使用<code>$.get()</code>,又或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的。</p>
<pre><code class="language-javascript">$.get('url',{name:'zs',age:20},function(){})
//等价于
$.get('url?name=zs&amp;age=20',function(){})

$.ajax({method:'GET',url:'url',data:{name:'zs',age:20},function(){} })
//等价于
$.ajax({method:'GET',url:'url?name=zs&amp;age=20',function(){} })
</code></pre>
<h2 id="url编码与解码">URL编码与解码</h2>
<h3 id="什么是url编码">什么是URL编码</h3>
<p>URL地址中，只允许出现英文相关的字母、标点符号、数字，因此，在URL地址中不允许出现中文字符。</p>
<p>如果URL中需要包含中文这样的字符，则必须对中文字符进行<strong>编码</strong>（转义）。</p>
<p><strong>URL编码的原则</strong>：使用安全的字符（没有特殊用途或者特殊意义的可以打印字符）去表示那些不安全的字符。</p>
<p>URL编码原则的通俗理解：使用<strong>英文字符</strong>去表示<strong>非英文字符</strong>。</p>
<pre><code class="language-javascript">http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=西游记
//经过URL编码之后，URL地址变成了如下格式：
http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0
//西        游        记
//%E8%A5%BF %E6%B8%B8 %E8%AE%B0
</code></pre>
<h3 id="如何对url进行编码与解码">如何对URL进行编码与解码</h3>
<p>浏览器提供了 URL 编码与解码的 API，分别是：</p>
<ul>
<li><code>encodeURL()</code> 编码的函数</li>
<li><code>decodeURL()</code> 编码的函数</li>
</ul>
<pre><code class="language-javascript">encodeURL('扣一送地狱火')
// 输出字符串 %E6%89%A3%E4%B8%80%E9%80%81%E5%9C%B0%E7%8B%B1%E7%81%AB
decodeURL('%E6%89%A3%E4%B8%80')
// 输出字符串 扣一
</code></pre>
<blockquote>
<p>注意：每三组<code>%</code>组成一个中文字符串</p>
</blockquote>
<h3 id="url编码的注意事项">URL编码的注意事项</h3>
<p>由于浏览器会自动对URL地址进行编码操作，因此大多数情况下，程序员不需要关心URL地址的编码与解码操作。</p>
<h2 id="使用xhr发起post请求">使用xhr发起POST请求</h2>
<p>步骤：</p>
<ol>
<li>创建xhr对象</li>
<li>调用<code>xhr.open()</code> 函数</li>
<li><strong>设置<code>Content-Type</code> 属性</strong>（固定写法）</li>
<li>调用<code>xhr.send()</code>属性，<strong>同时指定要发送的数据</strong></li>
<li>监听<code>xhr.onreadystatechange</code> 事件</li>
</ol>
<pre><code class="language-javascript">//1. 创建xhr对象 
var xhr = newXMLHttpRequest()
//2. 调用xhr.open()函数
xhr.open('POST','http://www.liulongbin.top:3006/api/addbook')
//3. 设置Content-Type属性（固定写法）
xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')
//4. 调用xhr.send()函数，同时将数据以查询字符串的方式，提交给服务器
xhr.send('bookname=水浒传&amp;author=施耐庵&amp;publisher=天津图书出版社')
//5. 监听xhr.onreadystatechange事件
xhr.onreadystatechange = function(){
    //5.1 监听xhr对象的请求状态 readyState;与服务器响应状态 status
    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
        //5.2 打印服务器响应回来的数据
        console.log(xhr.respanseText)
    }
}
</code></pre>
<h1 id="数据交换格式">数据交换格式</h1>
<h2 id="什么是数据交换格式">什么是数据交换格式</h2>
<p>数据交换格式，就是<strong>服务器端</strong>与<strong>客户端</strong>之间进行<strong>数据传输与交换的格式</strong>。</p>
<p>前端邻域，经常提及的两种数据交换格式分别是 <strong>XML</strong> 和 JSON 。其中 XML 用的非常少，故重点学习 JSON 数据交换格式。</p>
<h2 id="xml">XML</h2>
<h3 id="什么是-xml">什么是 XML</h3>
<p>XML 的英文全称是 E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage，即可拓展标记语言。因此，XML 和 HTML 类似，也是一种标记语言。</p>
<p>HTML：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Document&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>XML：</p>
<pre><code class="language-xml">&lt;node&gt;
	&lt;to&gt;ls&lt;/to&gt;
    &lt;form&gt;zs&lt;/form&gt;
    &lt;heading&gt;通知&lt;/heading&gt;
    &lt;body&gt;晚上开会&lt;/body&gt;
&lt;/node&gt;
</code></pre>
<h3 id="xml-和-html-的区别">XML 和 HTML 的区别</h3>
<p>XML 和HTML 虽然都是标记语言，但是两者之间没有任何的关系。</p>
<ul>
<li>HTML 被设计用来描述网页上的<strong>内容</strong>，是网页内容的载体</li>
<li>XML 被设计用来<strong>传输和存储数据</strong>，是数据的载体</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://shumild.github.io/post-images/1643807755806.png" alt="" loading="lazy"></figure>
<h3 id="xml-的缺点">XML 的缺点</h3>
<ol>
<li>XML 格式臃肿，和数据无关的代码多，体积大，传输效率低。</li>
<li>在 JavaScript 中解析 XML 比较麻烦</li>
</ol>
<h2 id="json">JSON</h2>
<h3 id="什么是-json">什么是 JSON</h3>
<p>JSON 的英文全称是<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation，即“ JavaScript 对象表示法”。简单来讲，JSON 就是 <strong>JavaScript 对象和数组的字符串表示法</strong>，它使用文本表示一个 JS 对象或数组的信息，因此，<strong>JSON 的本质是字符串</strong>。</p>
<p>作用：JSON 是一种<strong>轻量级的文本数据交换格式</strong>，在作用上类似于 XML，专门用于<strong>存储和传输数据</strong>，但是JSON 比XML <strong>更小、更快、更易解析</strong>。</p>
<p>现状：JSON 是在2001年开始被推广和使用的数据格式，距今为止，JSON 已经成为了<strong>主流的数据交换格式</strong>。</p>
<h3 id="json-的两种结构">JSON 的两种结构</h3>
<p>JSON 就是用字符串表示 JavaScript 的对象和数组。</p>
<p>JSON 中包含<strong>对象</strong>和<strong>数组</strong>两种结构，通过这两种结构<strong>互相嵌套</strong>，可表示各种复杂的数据结构。</p>
<p><strong>对象结构</strong>：对象结构在 JSON 中表示 <code>{}</code> 括起来的内容。数据结构为 <code>{ key:value,key:value,...}</code> 的键值对结构。其中，key 必须是使用<strong>英文的双引号包裹</strong>的字符串，value 的数据类型可以是<strong>数字、字符串、布尔值、null、数组、对象</strong>这6种类型。</p>
<p><strong>数组结构</strong>：数组结构在 JSON 中表示为 <code>[]</code> 括起来的内容。数据结构为 <code>[&quot;java&quot;,&quot;javascript&quot;,30,true ...]</code>。数组中数据的类型可以是<strong>数字、字符串、布尔值、null、数组、对象</strong>这6种类型。</p>
<h3 id="json-语法注意事项">JSON 语法注意事项</h3>
<ol>
<li>属性名必须使用双引号包裹。</li>
<li>字符串类型的值必须使用双引号包裹。</li>
<li>JSON 中不允许使用单引号表示字符串。</li>
<li>JSON 中不能写注释。</li>
<li>JSON 的最外层必须是对象或数组格式。</li>
<li>不能使用 undefined 或函数作为 JSON 的值。</li>
</ol>
<h3 id="json-和-js-对象的关系">JSON 和 JS 对象的关系</h3>
<p>JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。例如：</p>
<pre><code class="language-javascript">//这是一个对象
var obj = {a: 'Hello',b: 'World'}

//这是一个 JSON 字符串，本质是一个字符串
var json = '{&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;}'
</code></pre>
<h3 id="json-和-js-对象的互转">JSON 和 JS 对象的互转</h3>
<p>要实现从 JSON 字符串转换为 JS 对象，使用 <code>JSON.parse()</code> 方法：</p>
<pre><code class="language-javascript">var obj = JSON.parse('{&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;}')
//结果是{a:'Hello',b: 'World'}
</code></pre>
<h3 id="序列化和反序列化">序列化和反序列化</h3>
<p>把<strong>数据对象</strong>转换为<strong>字符串</strong>的过程，叫做<strong>序列化</strong>，例如：</p>
<p>​								调用 <code>JSON.stringify()</code> 函数的操作，叫做 JSON 序列化。</p>
<p>把<strong>字符串</strong>转换为<strong>数据对象</strong>的过程，叫做<strong>反序列化</strong>，例如：</p>
<p>​								调用 <code>JSON.parse()</code> 函数的操作，叫做 JSON 反序列化。</p>
<h1 id="封装自己的-ajax-函数">封装自己的 Ajax 函数</h1>
<h2 id="要实现的效果">要实现的效果</h2>
<pre><code class="language-html">&lt;!-- 1. 导入自定义的Ajax函数库 --&gt;
&lt;script src=&quot;./myAjax.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
	//2. 调用自定义的 myAjax 函数，发起 Ajax 数据请求
    myAjax({
        method:'请求类型',
        url:'请求地址',
        data:{/* 请求参数对象 */},
        success:function(res){ // 成功的回调函数
            console.log(res)   // 打印数据
        }
    })
&lt;/script&gt;
</code></pre>
<h2 id="定义-options-参数选项">定义 options 参数选项</h2>
<p><code>myAjax()</code> 函数是我们自定义的 Ajax 函数，它接收一个配置对象作为参数，配置对象中可以配置如下属性：</p>
<ul>
<li>method	请求类型</li>
<li>url            请求的 URL 地址</li>
<li>data         请求携带的数据</li>
<li>success    请求成功之后的回调函数</li>
</ul>
<h2 id="处理-data-参数">处理 data 参数</h2>
<p>需要把 data 对象，转化为查询字符串的格式，从而提交给服务器，因此提前定义 resolveData 函数如下：</p>
<pre><code class="language-javascript">/**
*	处理 data 参数
*	@param {data} 需要发送到服务器的数据
*	@returns {string} 返回拼接好的查询字符串 name=zs&amp;age=10
*/
function resolveData(data){
    var arr = []
    for(let k in data){
        arr.push(k + '=' + data[k])
    }
    return arr.join('&amp;')
}
</code></pre>
<h2 id="定义-myajax-函数">定义 myAjax 函数</h2>
<p>在 <code>myAjax()</code> 函数中，需要创建 xhr 对象，并监听 onreadystatechange 事件：</p>
<pre><code class="language-javascript">function myAjax(options){
    var xhr = new XMLHttpRequest()
    //拼接查询字符串
    var qs = resolveData(options.data)
    
    //监听请求状态改变的事件
    xhr.onreadystatechange = function(){
    	if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
        	var result = JSON.parse(xhr.respnseText)
        	options.success(result)
    	}
	}
}
</code></pre>
<h2 id="判断请求的类型">判断请求的类型</h2>
<p>不同的请求类型，对应 xhr 对象的不同操作，因此需要对请求类型进行判断：</p>
<pre><code class="language-javascript">if(options.method.toUpperCase() === 'GET'){
    // 发起 GET 请求
    xhr.open(options.method,options.url + '?' + qs )
    xhr.send()
}else if(options.method.toUpperCase() === 'POST'){
    // 发起 POST 请求
    xhr.open(options.method,options.url)
    xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')
    xhr.send(qs)
}
</code></pre>
<h1 id="xmlhttprequest-level2-的新特性">XMLHttpRequest Level2 的新特性</h1>
<h2 id="认识-xmlhttprequest-level2">认识 XMLHttpRequest Level2</h2>
<h3 id="旧版-xmlhttprequest-level2-的缺点">旧版 XMLHttpRequest Level2 的缺点</h3>
<ol>
<li>只支持文本数据的传输，无法用来读取和上传文件。</li>
<li>传送和接收数据时，没有进度信息，只能提示有没有完成。</li>
</ol>
<h3 id="xmlhttprequest-level2-的新功能">XMLHttpRequest Level2 的新功能</h3>
<ol>
<li>可以设置 HTTP 请求的时限。</li>
<li>可以使用 FormData 对象管理表单数据。</li>
<li>可以上传文件。</li>
<li>可以获得数据传输的进度信息。</li>
</ol>
<h2 id="设置-http-请求时限">设置 HTTP 请求时限</h2>
<p>有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限：</p>
<pre><code class="language-javascript">xhr.timeout = 3000
</code></pre>
<p>上面的语句，将最长等待事件设置为 3000 毫秒。过了这个时限，就自动停止 HTTP 请求。与之配套的还有一个 timeout 事件，用来指定回调函数：</p>
<pre><code class="language-javascript">xhr.ontimeout = function(event){
    alert('请求超时！')
}
</code></pre>
<h2 id="formdata-对象管理表单数据">FormData 对象管理表单数据</h2>
<p>Ajax 操作往往用来 提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作：</p>
<pre><code class="language-javascript">//1. 新建 FormData 对象
var fd = new FormData()
//2. 为 FormData 添加表单项
fd.append('uname','zs')
fd.append('upwd','123456')
//3. 创建 XHR 对象
var xhr = new XMLHttpRequest()
//4. 指定请求类型与 URL 地址
xhr.open('POST','http://www.liulongbin.top:3006/api/formdata')
//5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样
xhr.send(fd)
</code></pre>
<p>FormData 对象也可以用来获取表单的值，示例：</p>
<pre><code class="language-javascript">// 获取表单元素
var form = document.querySelector('#form1')
// 监听表单元素的 submit 事件
form.addEventListener('submit',function(e){
    e.preventDefault()
    // 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中
    var fd = new FormData(form)
    var xhr = new XMLHttpRequest()
    xhr.open('POST','http://www.liulongbin.top:3006/api/formdata')
    xhr.send(fd)
    xhr.onreadystatechange = function(){}
})
</code></pre>
<h2 id="上传文件">上传文件</h2>
<p>新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件。</p>
<p>步骤：</p>
<ol>
<li>定义 UI 结构。</li>
<li>验证是否选择了文件。</li>
<li>向 FormData 中追加文件。</li>
<li>使用 xhr 发起上传文件的请求。</li>
<li>监听 onreadystatechange 事件。</li>
</ol>
<h3 id="定义-ui-结构">定义 UI 结构</h3>
<pre><code class="language-html">&lt;!-- 1. 文件选择框 --&gt;
&lt;input type = &quot;flie&quot; id = &quot;file1&quot;&gt;
&lt;!-- 2. 上传按钮 --&gt;
&lt;button id = &quot;btnUpload&quot;&gt;上传文件&lt;/button&gt;
&lt;br/&gt;
&lt;!-- 3. 显示上传到服务器的上的图片 --&gt;
&lt;img src = &quot;&quot; alt = &quot;&quot; id = &quot;img&quot; width = &quot;800&quot; /&gt;
</code></pre>
<h3 id="验证是否选择了文件">验证是否选择了文件</h3>
<pre><code class="language-javascript">// 1. 获取上传文件的按钮
var btnUpload = document.querySelector('#btnUpload')
// 2. 为添加 click 事件监听
btnUpload.addEventListener('click',function(){
    // 3. 获取到选择的文件列表
    var files = document.querySelector('#file1').files
    if(files.length &lt;= 0){
        return alert('请选择要上传的文件！')
    }
    // ...后续业务逻辑
})
</code></pre>
<h3 id="向-formdata-中追加文件">向 FormData 中追加文件</h3>
<pre><code class="language-javascript">// 1. 创建 FormData 对象
var fd = new FormData()
// 2. 向 FormData 中追加文件
fd.append('avatar',files[0])
</code></pre>
<h3 id="使用-xhr-发起上传文件请求">使用 xhr 发起上传文件请求</h3>
<pre><code class="language-javascript">// 1. 创建 xhr 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open 函数，指定请求类型与 URL 地址。其中，请求类型必须为 POST
xhr.open('POST','http://www.liulingbin.top:3006/api/upload/avatar')
// 3. 发起请求
xhr.send(fd)
</code></pre>
<h3 id="监听-onreadystatechange-事件">监听 onreadystatechange 事件</h3>
<pre><code class="language-javascript">xhr.onreadystatechange = function(){
    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){
        var data = JSON.parse(xhr.responseText)
        if(data.status === 200){ // 上传文件成功
            // 将服务器返回的图片地址，设置为 &lt;img&gt; 标签的 src 属性
            document.querySelector('#img').src = 'http:www.liulingbin.top:3006' + data.url
        }else{ // 上传文件失败
        	console.log(data.message)
        }
    }
}
</code></pre>
<h2 id="显示文件上传进度">显示文件上传进度</h2>
<p>新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。</p>
<p>语法格式如下：</p>
<pre><code class="language-javascript">// 创建 XHR 对象
var xhr = new XMLHttpRequest()
// 监听 xhr.upload 的 onprogress 事件
xhr.upload.onprogress = function(e){
    // e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度
    if(e.lengthComputable){
        // e.loaded 已传输的字节
        // e.total  需传输的总字节
        var percentComplete = Math.ceil((e.loaded / e.total) * 100)
    }
}
</code></pre>
<h3 id="进度条美化">进度条美化</h3>
<p>使用 Bootstrap 的库或其他的库进行美化进度条</p>
<h3 id="监听上传进度的事件">监听上传进度的事件</h3>
<pre><code class="language-javascript">xhr.upload.onprogress = function(e){
    if(e.lengthComputable){
        // 1. 计算出当前上传进度的百分比
        var percentComplete = Math.ceil((e.load / e.total) * 100)
        $('#percent')
        	// 2. 设置进度条的宽度
        	.attr('style','width:' + percentComplete + '%')
        	// 3. 显示当前的上传进度百分比
        	.html(percentComplete + '%')
    }
}
</code></pre>
<h3 id="监听上传完成的事件">监听上传完成的事件</h3>
<pre><code class="language-javascript">xhr.upload.onload = function(){
    $('#percent')
    	// 移除上传中的类样式
    	.removeClass()
    	// 添加上传完成的类样式
    	.addClass('progress-bar progress-bar-success')
}
</code></pre>
<h1 id="jquery-高级用法">jQuery 高级用法</h1>
<h2 id="jquery-实现文件上传">jQuery 实现文件上传</h2>
<h3 id="定义-ui-结构-2">定义 UI 结构</h3>
<pre><code class="language-html">&lt;!-- 导入 jQuery --&gt;
&lt;script src=&quot;./jquery.js&quot;&gt;&lt;/script&gt;
&lt;!-- 文件选择框 --&gt;
&lt;input type = &quot;file&quot; id = &quot;file1&quot; /&gt;
&lt;!-- 上传文件按钮 --&gt;
&lt;button id = &quot;btnUpload&quot;&gt;上传&lt;/button&gt;
</code></pre>
<h3 id="验证是否选择了文件-2">验证是否选择了文件</h3>
<pre><code class="language-javascript">$('#btnUpload').on('click',function(){
    // 1. 将 jQuery 对象转化为 DOM 对象，并获取选中的文件列表
    var files = $('#file1')[0].files
    // 2. 判断是否选择了文件
    if(files.length &lt;= 0){
        return alert('请选择图片后再上传！')
    }
})
</code></pre>
<h3 id="向-formdata-中追加文件-2">向 FormData 中追加文件</h3>
<pre><code class="language-javascript">// 向 FormData 中追加文件
var fd = new FormData()
fd.append('avatar',files[0])
</code></pre>
<h3 id="使用-jquery-发起上传文件的请求">使用 jQuery 发起上传文件的请求</h3>
<pre><code class="language-javascript">$.ajax({
    method:'POST',
    url:'http://www.liulongbin.top:3006/api/upload/avatar',
    data:fd,
    // 不修改 Content-Type 属性，使用 FormData 默认的 Content-Type 值
    contentType:false,
    // 不对 FormData 中的数据进行 url 编码，而是将 FormData 数据原样发送到服务器
    processData:fales,
    success:function(res){
        console.log(res)
    }
})
</code></pre>
<h2 id="jquery-实现-loading-效果">jQuery 实现 loading 效果</h2>
<h3 id="ajaxstartcallback">ajaxStart（callback）</h3>
<p>Ajax 请求<strong>开始</strong>时，执行ajaxStart 函数。可以在 ajaxStart 的 callback 中显示 loading 效果，示例：</p>
<pre><code class="language-javascript">//自 jQuery 版本 1.8 起，该方法只能被附加到文档
$(document).ajaxStart(function(){
    $('#loading').show()
})
</code></pre>
<blockquote>
<p><strong>注意</strong>：<code>$(document).ajaxStart()</code> 函数会监听当前文档内所有的 Ajax 请求</p>
</blockquote>
<h3 id="ajaxstopcallback">ajaxStop（callback）</h3>
<p>Ajax 请求<strong>结束</strong>时，执行 ajaxStop 函数。可以在 ajaxStop 的 callback 中隐藏 loading 效果，示例：</p>
<pre><code class="language-javascript">//自 jQuery 版本 1.8 起，该方法只能被附加到文档
$(document).ajaxStop(function(){
    $('#loading').hide()
})
</code></pre>
<h1 id="axios">axios</h1>
<h2 id="什么是-axios">什么是 axios</h2>
<p>Axios 是专注于<strong>网络数据请求</strong>的库。</p>
<p>相比于原生的 XMLHttpRequest 对象，axios <strong>简单易用</strong>。</p>
<p>相比于 jQuery，axios 更加<strong>轻量化</strong>，只专注于网络数据请求。</p>
<h2 id="axios-发起-get-请求">axios 发起 GET 请求</h2>
<p>语法：</p>
<pre><code class="language-javascript">axios.get('url',{params:{ /*参数*/ }}).then(callback)
</code></pre>
<p>具体的请求示例如下：</p>
<pre><code class="language-javascript">// 请求的 URL 地址
var url = 'http://www.liulongbin.top:3006/api/get'
// 请求的参数对象
var paramsObj = { name: 'zs', age: 20}
// 调用 axios.get() 发起 GET 请求
axios.get(url,{ params: paramsObj }).then(function(res){
    // res.data 是服务器返回的数据
    var result = res.data
    console.log(result)
})
</code></pre>
<h2 id="axios-发起-post-请求">axios 发起 POST 请求</h2>
<p>axios 发起 post 请求的语法：</p>
<pre><code class="language-javascript">axios.post('url',{ /*参数*/ }).then(callback)
</code></pre>
<p>具体的请求示例如下：</p>
<pre><code class="language-javascript">// 请求的 URL 地址
var url = 'http://www.liulongbin.top:3006/api/post'
// 要提交到服务器的数据
var dataObj = { name: 'zs', age: 20}
// 调用 axios.post() 发起 POST 请求
axios.get(url, dataObj).then(function(res){
    // res.data 是服务器返回的数据
    var result = res.data
    console.log(result)
})
</code></pre>
<h2 id="直接使用-axios-发起请求">直接使用 axios 发起请求</h2>
<h3 id="直接使用-axios-发起-get-请求">直接使用 axios 发起 GET 请求</h3>
<pre><code class="language-javascript">axios({
    method: 'GET',
    url: 'http://www.liulongbin.top:3006/api/get',
    params: {// GET 参数要通过 params 属性提供
    	name: 'zs',
        age: 20
    }
}).then(function(res){
    console.log(res.data)
})
</code></pre>
<h3 id="直接使用-axios-发起-post-请求">直接使用 axios 发起 POST 请求</h3>
<pre><code class="language-javascript">axios({
    method: 'POST',
    url: 'http://www.liulongbin.top:3006/api/post',
    data: {// POST 参数要通过 data 属性提供
    	name: 'zs',
        age: 20
    }
}).then(function(res){
    console.log(res.data)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[form表单和模板引擎]]></title>
        <id>https://shumild.github.io/post/form-biao-dan-he-mo-ban-yin-qing/</id>
        <link href="https://shumild.github.io/post/form-biao-dan-he-mo-ban-yin-qing/">
        </link>
        <updated>2022-01-19T13:17:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="form表单的基本使用">form表单的基本使用</h1>
<h2 id="什么是表单">什么是表单</h2>
<p>表单在网页中主要负责<strong>数据采集功能</strong>。HTML中的<code>&lt;form&gt;</code>标签，就是用于采集用户输入的信息，并通过<code>&lt;form&gt;</code>标签的提交操作，把采集到的信息提交到服务器端进行处理。</p>
<h2 id="表单的组成部分">表单的组成部分</h2>
<pre><code class="language-html">&lt;from&gt;
	&lt;input type = &quot;text&quot; name = &quot;email_or_mobile&quot; /&gt;
    &lt;input type = &quot;password&quot; name = &quot;password&quot; /&gt;
    &lt;input type = &quot;checkbox&quot; name = &quot;remember_me&quot; checked /&gt;
    &lt;button type = &quot;submit&quot; &gt;提交&lt;/button&gt;
&lt;/from&gt;
</code></pre>
<p>表单由三个部分组成：</p>
<ul>
<li>表单标签</li>
<li>表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。</li>
<li>表单按钮</li>
</ul>
<h2 id="form-标签的属性">&lt; form &gt;标签的属性</h2>
<p><code>&lt;form&gt;</code>标签用来采集数据，<code>&lt;form&gt;</code>标签的属性是用来规定<strong>如何把采集到的信息发送到服务器</strong>。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td>URL地址</td>
<td>规定当提交表单时，向何处发送表单数据</td>
</tr>
<tr>
<td>method</td>
<td>get或post</td>
<td>规定以何种方式把表单数据提交到 action URL</td>
</tr>
<tr>
<td>enctype</td>
<td>application/x-www-form-urlencoded<br>multipart/form-data<br>text/plain</td>
<td>规定在发送表单数据之前如何对其进行编码</td>
</tr>
<tr>
<td>target</td>
<td>_____blank<br>_____self<br>_____parent <br>_____top<br> framename</td>
<td>规定在何处打开 action URL</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="action">action</h3>
<p>action 属性用来规定当提交表单时，<strong>向何处发送表单数据</strong>。</p>
<p>action 属性的值应该是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。</p>
<p>当 <code>&lt;from&gt;</code>表单在未指定 action 属性值的情况下，action 的默认值为当前页面的 URL 地址。</p>
<blockquote>
<p><strong>注意</strong>：当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址</p>
</blockquote>
<hr>
<h3 id="target">target</h3>
<p>target 属性用来规定<strong>在何处打开 action URL</strong>。</p>
<p>它的可选值有5个，默认情况下，target 的值是 _self，表示在相同的框架中打开 action URL。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>_blank</strong></td>
<td><strong>在新窗口中打开。</strong></td>
</tr>
<tr>
<td><strong>_self</strong></td>
<td><strong>默认。在相同的框架中打开。</strong></td>
</tr>
<tr>
<td>_parent</td>
<td>在父框架集中打开。（很少用）</td>
</tr>
<tr>
<td>_top</td>
<td>在整个窗口中打开。（很少用）</td>
</tr>
<tr>
<td>framename</td>
<td>在指定的框架中打开。（很少用）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="method">method</h3>
<p>method 属性用来规定以何种方式把表单数据提交到 action URL。</p>
<p>它的可选值有两个，分别是 get 和 post 。</p>
<p>默认情况下，method 的值为 get ，表示通过URL地址的形式，把表单数据提交到 action  URL。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p><strong>get</strong> 方式适合用来提交少量的、简单的数据。</p>
<p><strong>post</strong> 方式适合用来提交<strong>大量的</strong>、<strong>复杂的</strong>、或包含<strong>文件上传</strong>的数据。</p>
<p>在实际开发中，<code>&lt;form&gt;</code> 表单的 post 提交方式用的最多，很少用 get。例如登录、注册、添加数据等表单操作，都需要使用 post 方式来提交表单。</p>
</blockquote>
<hr>
<h3 id="enctype">enctype</h3>
<p>enctype 属性用来规定在发送表单 数据之前如何对数据进行编码。</p>
<p>它的可选值有三个，默认情况下，enctype 的值为 application/x-www-form-urlencoded，表示在发送前编码所有的字符。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>application/x-www-form-urlencoded</td>
<td>在发送前编码所有字符（默认）</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</td>
</tr>
<tr>
<td>text/plain</td>
<td>空格转换为 “+” 加号，但不对特殊字符编码。（很少用）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：</p>
<p>在涉及到<strong>文件上传</strong>的操作时，<strong>必须</strong>将 enctype 的值设置为 <strong>multipart/form-data</strong></p>
<p>如果表单的提交不涉及到上传操作，则直接将 enctype 的值设置为 application/x-www-form-urlencoded 即可</p>
</blockquote>
<h2 id="表单的同步提交及缺点">表单的同步提交及缺点</h2>
<h3 id="什么是表单的同步提交">什么是表单的同步提交</h3>
<p>通过点击 submit 按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交。</p>
<h3 id="表单同步提交的缺点">表单同步提交的缺点</h3>
<ol>
<li><code>&lt;form&gt;</code>表单同步提交后，整个页面会发生跳转，<strong>跳转到 action URL 所指向的地址</strong>，用户体验很差。</li>
<li><code>&lt;form&gt;</code>表单同步提交后，<strong>页面之前的状态和数据会丢失</strong>。</li>
</ol>
<h3 id="解决表单同步提交的缺点">解决表单同步提交的缺点</h3>
<p>解决方案：<strong>表单</strong>只负责<strong>采集数据</strong>，<strong>Ajax</strong>负责<strong>将数据提交到服务器</strong></p>
<h1 id="通过ajax提交表单数据">通过Ajax提交表单数据</h1>
<h2 id="监听表单提交事件">监听表单提交事件</h2>
<p>在jQuery中，可以使用如下两种方式，监听到表单的提交事件：</p>
<pre><code class="language-javascript">$('#form').submit(function(e){
    alert('监听到了表单的提交事件')
})

$('#form').on('submit',function(e){
    alert('监听到了表单的提交事件')
})
</code></pre>
<h2 id="阻止表单默认提交行为">阻止表单默认提交行为</h2>
<p>当监听到表单的提交事件以后，可以调用事件对象的 <code>event.preventDefault()</code>函数，来阻止表单的提交和页面的跳转：</p>
<pre><code class="language-javascript">$('#form').submit(function(e){
    //阻止表单的提交和页面的跳转
    e.preventDefault()
})

$('#form').on('submit',function(e){
    //阻止表单的提交和页面的跳转
    e.preventDefault()
})
</code></pre>
<h2 id="快速获取表单中的数据">快速获取表单中的数据</h2>
<h3 id="serialize-函数">serialize() 函数</h3>
<p>为了简化表单中数据的获取操作，jQuery提供了 <code>serialize()</code> 函数，其语法格式如下：</p>
<pre><code class="language-javascript">$(selector).serialize()
</code></pre>
<p><code>serialize()</code>函数的好处：可以<strong>一次性获取到表单中的所有的数据</strong></p>
<h3 id="serialize-函数示例">serialize() 函数示例</h3>
<pre><code class="language-html">&lt;form id=&quot;form&quot;&gt;
	&lt;input type = &quot;text&quot; name = &quot;username&quot; /&gt;
    &lt;input type = &quot;password&quot; name = &quot;password&quot; /&gt;
    &lt;button type = &quot;submit&quot; &gt;提交&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-javascript">$('#form').serialize()
// 调用的结果：
// username = 用户名的值 &amp; password = 密码的值
</code></pre>
<blockquote>
<p><strong>注意</strong>：在使用<code>serialize()</code> 函数快速获取表单数据时，<strong>必须为每个表单元素添加 name 属性</strong></p>
</blockquote>
<h1 id="模板引擎的基本概念">模板引擎的基本概念</h1>
<h2 id="渲染ui结构时遇到的问题">渲染UI结构时遇到的问题</h2>
<pre><code class="language-javascript">var rows=[]
$.each(res.data,function (i,item){ //循环拼接字符串
	rows.push('&lt;li class=&quot;list-group-item&quot;&gt;'+item.content+'&lt;span class=&quot;badge cmt-date&quot;&gt;评论时间：'+item.time+'&lt;/span&gt;&lt;span class=&quot;badge cmt-date&quot;&gt;评论人：'+item.username+'&lt;/span&gt;&lt;/li&gt;')
})
$('#cmt-list').empty().append(rows.join('')) //渲染列表的UI结构
</code></pre>
<p>以上代码是通过<strong>字符串拼接</strong>的形式，来渲染UI结构。</p>
<p>如果UI结构比较复杂，则拼接字符串的时候需要格外注意<strong>引号之前的嵌套</strong>。且一旦需求发生变化，<strong>修改起来也非常麻烦</strong>。</p>
<h2 id="什么是模板引擎">什么是模板引擎</h2>
<p>模板引擎能根据程序员指定的<strong>模板结构</strong>和<strong>数据</strong>，自动生成一个完整的HTML页面</p>
<p><img src="https://shumild.github.io/post-images/1643807968304.png" alt="" loading="lazy">!</p>
<h2 id="模板引擎的好处">模板引擎的好处</h2>
<ol>
<li>减少了字符串的拼接操作</li>
<li>使代码结构更清晰</li>
<li>使代码更易于阅读和维护</li>
</ol>
<h1 id="art-template模板引擎">art-template模板引擎</h1>
<p>art-template是一个简约、超快的模板引擎。中文官网首页为<a href="http://aui.github.io/art-template/zh-cn/">art-template (aui.github.io)</a></p>
<h2 id="art-template的安装">art-template的安装</h2>
<p>在浏览器中访问<a href="http://aui.github.io/art-template/zh-cn/docs/installation.html">安装 - art-template (aui.github.io)</a></p>
<p>找到下载链接后，鼠标右键，选择另存为，将art-template下载到本地，通过<code>&lt;scrip&gt;</code>标签加载到网页上使用。</p>
<h2 id="art-template模板引擎的基本使用">art-template模板引擎的基本使用</h2>
<h3 id="使用传统方式渲染ui结构">使用传统方式渲染UI结构</h3>
<pre><code class="language-html">&lt;body&gt;
	&lt;div id=&quot;title&quot;&gt;&lt;/div&gt;  
    &lt;div&gt;姓名：&lt;span id=&quot;name&quot;&gt;&lt;/span&gt;&lt;/div&gt;
 	&lt;div&gt;年龄：&lt;span id=&quot;age&quot;&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;会员：&lt;span id=&quot;isVIP&quot;&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;注册时间：&lt;span id=&quot;regTime&quot;&gt;&lt;/span&gt;&lt;/div&gt;
	&lt;div&gt;
        爱好：
        &lt;ul id=&quot;hobby&quot;&gt;
            &lt;li&gt;爱好1&lt;/li&gt;
            &lt;li&gt;爱好2&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;


&lt;script&gt;
var data = {
    title:'&lt;h3&gt;用户信息&lt;/h3&gt;',
    name:'zs',
    age:20,
    isVIP:true,
    regTime:new Date(),
    hobby:['吃饭','吃饭','吃饭']
}

$(function(){
    $('#name').html(data.name)
    $('#title').html(data.title)
    $('#age').html(data.age)
    $('#isVIP').html(data.isVIP)
    $('#regTime').html(data.regTime)
    
    var rows = []
    $.each(data.hobby,function(i,item){
        rows.push('&lt;li&gt;'+item+'&lt;/li&gt;')
    })
    $('#hobby').html(rows.join(''))
})
&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="art-template的使用步骤">art-template的使用步骤</h3>
<ol>
<li>导入art-template</li>
<li>定义数据</li>
<li>定义模板</li>
<li>调用template函数</li>
<li>渲染HTML结构</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!--1. 导入模板引擎--&gt;
    &lt;!--在windows全局，多一个函数，叫做 template（‘模板的Id’，需要渲染的数据对象）--&gt;
    &lt;script src=&quot;../public/js/template-web.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../public/js/jquery.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;

&lt;!--3. 定义模板--&gt;
&lt;!--3.1 模板的 HTML 结构，必须定义到 script 中--&gt;
&lt;script type=&quot;text/html&quot; id=&quot;tpl-user&quot;&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
&lt;/script&gt;

&lt;script&gt;
    //2. 定义需要渲染的数据
    var data = { name:'zs'}

    //4. 调用 template 函数
    var htmlStr = template('tpl-user',data)
    console.log(htmlStr)
    //5. 渲染 HTML 结构
    $('#container').html(htmlStr)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="art-template标准语法">art-template标准语法</h3>
<h4 id="什么是标准-语法">什么是标准 语法</h4>
<p>art-template 提供了<code>{{ }}</code>这种语法格式，在<code>{{ }}</code>内可以进行变量输出，或循环数组等操作，这种<code>{{ }}</code>语法在art-template中被称为标准语法。</p>
<h4 id="标准语法-输出">标准语法 — 输出</h4>
<pre><code class="language-javascript">{{value}}
{{obj.key}}
{{obj['key']}}
{{a?b:c}}
{{a||b}}
{{a + b}}
</code></pre>
<p>在<code>{{}}</code>语法中，可以进行<strong>变量</strong>的输出、<strong>对象属性</strong>的输出、<strong>三元表达式</strong>输出、<strong>逻辑或</strong>输出、<strong>加减乘除等表达式</strong>输出。</p>
<h4 id="标准语法-原文输出">标准语法 — 原文输出</h4>
<pre><code class="language-javascript">{{@ value}}
</code></pre>
<p>如果要输出的value值中，包含了HTML标签结构，则需要使用<strong>原文输出</strong>语法，才能保证HTML标签被正常渲染。</p>
<h4 id="标准语法-条件输出">标准语法 — 条件输出</h4>
<p>如果要实现条件输出，则可以在<code>{{}}</code>中使用<strong>if…else if…/if</strong>的方式，按需输出。</p>
<pre><code class="language-javascript">{{if value}} 按需输出的内容 {{/if}}
                       
{{if vl}} 按需输出的内容 {{else if v2}} 按需输出的内容 {{/if}}
</code></pre>
<h4 id="标准语法-过滤器">标准语法 — 过滤器</h4>
<p>过滤器的本质是一个 function 处理函数</p>
<pre><code class="language-javascript">{{value|filterName}}
</code></pre>
<p>过滤器语法类似<strong>管道操作符</strong>，它的上一个输出作为下一个输入。</p>
<p>定义过滤器的基本语法如下：</p>
<pre><code class="language-javascript">template.defaults.imports.filterName = function(value){/*return 处理结果*/}
</code></pre>
<pre><code class="language-html">&lt;div&gt;注册时间：{{regTime|dateFormat}}&lt;/div&gt;
</code></pre>
<p>定义一个格式化的过滤器 dateFormat 如下：</p>
<pre><code class="language-javascript">template.defaults.imports.dateFormat = function(date){
    var y = date.getFullYear()
    var m = date.getMonth() + 1
    var d = date.getDate()
    
    return y + '-' + m + '-' + d //注意：过滤器最后一定要return一个值
}
</code></pre>
<h1 id="模板引擎的实现原理">模板引擎的实现原理</h1>
<h2 id="正则与字符串操作">正则与字符串操作</h2>
<h3 id="基本语法">基本语法</h3>
<p><code>exec()</code>函数用于字符串中的正则表达式的匹配。</p>
<p>如果字符串中有匹配的值，返回该匹配值，否则返回null。</p>
<pre><code class="language-javascript">RegExpObject.exec(string)
</code></pre>
<p>示例代码如下：</p>
<pre><code class="language-javascript">var str = 'hello'
var pattern = /o/
// 输出的结果[&quot;o&quot;,index:4,input:&quot;hello&quot;,groups:undefined]
console.log(pattern.exec(str))
</code></pre>
<h3 id="分组">分组</h3>
<p>正则表达式中<code>()</code>包含起来的内容表示一个分组，可以通过分组来提取自己想要的内容，示例：</p>
<pre><code class="language-javascript">var str = '&lt;div&gt; 我是{{name}} &lt;/div&gt;'
var pattern = /{{([a-zA-Z]+)}}/

var patternResult = pattern.exec(str)
console.log(patternResult)
//得到 name 相关的分组信息
//[&quot;{{name}}&quot;,&quot;name&quot;,index:7,input:&quot;&lt;div&gt;我是{{name}}&lt;/div&gt;&quot;,groups:undefined]
</code></pre>
<h3 id="字符串的replace函数">字符串的replace函数</h3>
<p>replace()函数用于在字符串中用一些字符替换另一些字符，语法格式如下：</p>
<pre><code class="language-javascript">var result = '123456'.replace('123','abc') // 得到的 result 的值为字符串 ‘abc456’
</code></pre>
<p>示例：</p>
<pre><code class="language-javascript">var str = '&lt;div&gt;我是{{name}}&lt;/div&gt;'
var pattern = /{{([a-zA-Z]+)}}/

var patternResult = pattern.exec(str)
str = str.replace(patternResult[0],patternResult[1])
//replace 函数返回值为替换后的新字符串
//输出的内容：&lt;div&gt;我是name&lt;/div&gt;
console.log(str)
</code></pre>
<h3 id="多次replace">多次replace</h3>
<pre><code class="language-javascript">var str = '&lt;div&gt;{{name}}今年{{age}}岁了&lt;/div&gt;'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = pattern.exec(str)
str = str.replace(patternResult[0],patternResult[1])
console.log(str)//输出 &lt;div&gt;name今年{{age}}岁了&lt;/div&gt;

patternResult = pattern.exec(str)
str = str.replace(patternResult[0],patternResult[1])
console.log(str)// 输出 &lt;div&gt;name今年age岁了&lt;/div&gt;

patternResult = pattern.exec(str)
console.log(patternResult)// 输出 null
</code></pre>
<h3 id="使用while循环replace">使用while循环replace</h3>
<pre><code class="language-javascript">var str = '&lt;div&gt;{{name}}今年{{age}}岁了&lt;/div&gt;'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = null
while(patternResult = pattern.exec(str)){
    str = str.replace(patternResult[0],patternResult[1])
}
console.log(str) //输出 &lt;div&gt;name今年age岁了&lt;/div&gt;
</code></pre>
<h3 id="replace替换为真值">replace替换为真值</h3>
<pre><code class="language-javascript">var data = {name:'zhangsan',age:20}
var str = '&lt;div&gt;{{name}}今年{{age}}岁了&lt;/div&gt;'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = null
while(patternResult = pattern.exec(str)){
    str = str.replace(patternResult[0],data[patternResult[1]])
}
console.log(str)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识 Ajax]]></title>
        <id>https://shumild.github.io/post/chu-shi-ajax/</id>
        <link href="https://shumild.github.io/post/chu-shi-ajax/">
        </link>
        <updated>2022-01-15T15:01:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="了解ajax">了解Ajax</h1>
<h2 id="什么是ajax">什么是Ajax</h2>
<p>Ajax全称是Asynchronous Javascript And XML（异步JavaScript 和 XML）。</p>
<p>通俗的理解：在网页中利用XMLHttpRequest 对象和服务器进行 数据交互的方式，就是Ajax。</p>
<h2 id="为什么要学ajax">为什么要学Ajax</h2>
<p><strong>Ajax</strong>能让我们轻松实现<strong>网页</strong>与<strong>服务器</strong>之间的<strong>数据交互</strong></p>
<h1 id="jquery中的ajax">jQuery中的Ajax</h1>
<h2 id="了解jquery中的ajax">了解jQuery中的Ajax</h2>
<p>浏览器中提供的<strong>XMLHttpRequest用法比较复杂</strong>，所以jQuery对XMLHttpRequest进行了封装，提供了一系列Ajax相关的函数，极大地<strong>降低了Ajax的使用难度</strong>。</p>
<p>jQuery中发起Ajax请求最常用的三个方法：</p>
<ul>
<li><strong>$.get()</strong></li>
<li><strong>$.post()</strong></li>
<li><strong>$.ajax()</strong></li>
</ul>
<h2 id="get函数的语法">$.get()函数的语法</h2>
<p>jQuery中<code>$.get()</code>函数的功能单一，专门用来发起get请求，从而将服务器上的资源请求到客户端来进行使用。</p>
<p>$.get()函数的语法如下：</p>
<pre><code class="language-javascript">$.get(url,[data],[callback])
</code></pre>
<p>其中，三个参数各自代表的含义如下：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>是否必选</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>url</strong></td>
<td><strong>string</strong></td>
<td><strong>是</strong></td>
<td>要请求的<strong>资源地址</strong></td>
</tr>
<tr>
<td>data</td>
<td>object</td>
<td>否</td>
<td>请求资源期间要<strong>携带的参数</strong></td>
</tr>
<tr>
<td>callback</td>
<td>function</td>
<td>否</td>
<td>请求成功时的<strong>回调函数</strong></td>
</tr>
</tbody>
</table>
<h2 id="get发起不带参数的请求">$.get()发起不带参数的请求</h2>
<p>使用<code>$.get()</code>函数发起不带参数的请求时，直接提供请求的URL地址和请求成功之后的回调函数即可，示例代码如下：</p>
<pre><code class="language-javascript">$.get('http://www.liulongbin.top:3006/api/getbooks',function(res){
    console.log(res)//这里的res是服务器返回的数据
})
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://shumild.github.io/post-images/1642951861423.png" alt="" loading="lazy"></figure>
<h2 id="get发起带参数的请求">$.get()发起带参数的请求</h2>
<p>使用<code>$.get()</code>函数发起带参数的请求时，示例代码如下：</p>
<pre><code class="language-javascript">$.get('http://www.liulongbin.top:3006/api/getbooks',{id:1},function(res){
    console.log(res)
})
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://shumild.github.io/post-images/1642951912044.png" alt="" loading="lazy"></figure>
<h2 id="post函数的语法">$.post()函数的语法</h2>
<p>jQuery中<code>$.post()</code>函数功能单一，专门用来发起post请求，从而向服务器提交数据。</p>
<p>$.post()函数的语法如下：</p>
<pre><code class="language-javascript">$.post(url,[data],[callback])
</code></pre>
<p>其中，三个参数各自代表的含义如下：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>是否必选</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>url</strong></td>
<td><strong>string</strong></td>
<td><strong>是</strong></td>
<td><strong>提交数据的地址</strong></td>
</tr>
<tr>
<td>data</td>
<td>object</td>
<td>否</td>
<td><strong>要提交的数据</strong></td>
</tr>
<tr>
<td>callback</td>
<td>function</td>
<td>否</td>
<td>数据提交成功时的<strong>回调函数</strong></td>
</tr>
</tbody>
</table>
<h2 id="post向服务器提交数据">$.post()向服务器提交数据</h2>
<p>使用$.post()向服务器提交数据的示例代码如下：</p>
<pre><code class="language-javascript">$.post('http://www.liulongbin.top:3006/api/addbook', //请求的URL地址
       {bookname:'水浒传',author:'施耐庵',publisher:'上海图书出版社'}, //提交的数据
      function(res){ //回调函数
    console.log(res)
})
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://shumild.github.io/post-images/1642952086210.png" alt="" loading="lazy"></figure>
<h2 id="ajax函数的语法">$.ajax()函数的语法</h2>
<p>相比于<code>$.get()</code>和<code>$.post()</code>函数，jQuery中提供的<code>$.ajax()</code>函数，是一个功能比较综合的函数，它允许我们对Ajax请求进行更详细的配置。</p>
<p>$.ajax()函数配置基本语法如下：</p>
<pre><code class="language-javascript">$.ajax({
    type:'', // 请求的方式，例如 GET 或 POST
    url:'', // 请求 URL 地址
    data:{ }, // 这次请求要携带的数据
    success:function(res){ } // 请求成功之后的回调函数
})
</code></pre>
<h2 id="使用ajax发起get请求">使用$.ajax()发起GET请求</h2>
<p>使用<code>$.ajax()</code>发起GET请求时，只需要将<strong>type属性</strong>的值设置为 ‘ <strong>GET</strong> ’ 即可：</p>
<pre><code class="language-javascript">$.ajax({
    type:'GET', // 请求的方式
    url:'http://www.liulongbin.top:3006/api/getbooks', // 请求 URL 地址
    data:{id:1}, // 这次请求要携带的数据
    success:function(res){ // 请求成功之后的回调函数
        console.log(res)
    } 
})
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://shumild.github.io/post-images/1642952132798.png" alt="" loading="lazy"></figure>
<h2 id="使用ajax发起post请求">使用$.ajax()发起POST请求</h2>
<p>使用<code>$.ajax()</code>发起POST请求时，只需将<strong>type属性</strong>的值设置为 ‘ <strong>POST</strong> ’ 即可：</p>
<pre><code class="language-javascript">$.ajax({
    type:'POST', // 请求的方式
    url:'http://www.liulongbin.top:3006/api/addbook', // 请求 URL 地址
    data:{ // 要提交给服务器的数据
        bookname:'水浒传',
        author:'施耐庵',
        publisher:'上海图书出版社'
    }, 
    success:function(res){ // 请求成功之后的回调函数
        console.log(res)
    }
})
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://shumild.github.io/post-images/1642952152789.png" alt="" loading="lazy"></figure>
<h1 id="接口">接口</h1>
<h2 id="接口的概念">接口的概念</h2>
<p>使用Ajax请求数据时，被请求的URL地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式。</p>
<p>例如：</p>
<blockquote>
<p>http://www.liulongbin.top:3006/api/getbooks 			获取图书列表的接口（GET请求）</p>
</blockquote>
<blockquote>
<p>http://www.liulongbin.top:3006/api/addbooks			添加图书的接口（POST请求）</p>
</blockquote>
<h2 id="分析接口的请求过程">分析接口的请求过程</h2>
<h3 id="1通过get方式请求接口的过程">1.通过GET方式请求接口的过程</h3>
<figure data-type="image" tabindex="6"><img src="https://shumild.github.io/post-images/1642952219056.png" alt="" loading="lazy"></figure>
<h3 id="2通过post方式请求接口的过程">2.通过POST方式请求接口的过程</h3>
<figure data-type="image" tabindex="7"><img src="https://shumild.github.io/post-images/1642955048190.png" alt="" loading="lazy"></figure>
<h2 id="接口测试工具">接口测试工具</h2>
<h3 id="1什么是接口测试工具">1.什么是接口测试工具</h3>
<p>为了验证接口能否被正常访问，我们常常需要使用接口测试工具，来对数据接口进行检测。</p>
<p><strong>好处</strong>：接口测试工具能让我们在<strong>不写任何代码</strong>的情况下，对接口进行<strong>调用</strong>与<strong>测试</strong>。</p>
<h3 id="2下载并安装postman">2.下载并安装PostMan</h3>
<p>访问PostMan的官方下载网址https://www.getpostman.com/downloads/，下载所需的安装程序后，直接安装即可。</p>
<h3 id="3了解postman界面的组成部分">3.了解PostMan界面的组成部分</h3>
<p>PostMan界面的组成部分，从上到下，从左到右，分别是：</p>
<figure data-type="image" tabindex="8"><img src="https://shumild.github.io/post-images/1642952239618.png" alt="" loading="lazy"></figure>
<h3 id="4使用postman测试get接口">4.使用PostMan测试GET接口</h3>
<p>步骤：</p>
<ol>
<li>选择请求的方式</li>
<li>填写请求的URL地址</li>
<li>填写请求的参数</li>
<li>点击Send按钮发起GET请求</li>
<li>查看服务器响应的结果</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://shumild.github.io/post-images/1642952256470.png" alt="" loading="lazy"></figure>
<h3 id="5使用postman测试post接口">5.使用PostMan测试POST接口</h3>
<p>步骤：</p>
<ol>
<li>选择请求的方式</li>
<li>填写请求的URL地址</li>
<li>选择Body面板并<strong>勾选数据格式</strong></li>
<li>填写要发送到服务器的数据</li>
<li>点击Send按钮发起POST请求</li>
<li>查看服务器响应的结果</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://shumild.github.io/post-images/1642952273759.png" alt="" loading="lazy"></figure>
<h2 id="接口文档">接口文档</h2>
<h3 id="1什么是接口文档">1.什么是接口文档</h3>
<p>接口文档，顾名思义就是<strong>接口的说明文档</strong>，它是我们<strong>调用接口的依据</strong>。好的接口文档包含了对<strong>接口URL</strong>，<strong>参数</strong>以及<strong>输出内容</strong>的说明，我们参照接口文档就能方便的知道接口的作用，如何进行调用。</p>
<h3 id="2接口文档的组成部分">2.接口文档的组成部分</h3>
<p>接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下6项内容，从而为接口的调用提供依据：</p>
<ol>
<li><strong>接口名称</strong>：用来标识各个接口的简单说明，如<strong>登录接口</strong>，<strong>获取图书列表接口</strong>等。</li>
<li><strong>接口 URL</strong>：接口的调用地址。</li>
<li><strong>调用方式</strong>：接口的调用方式，如 <strong>GET</strong> 或 <strong>POST</strong>。</li>
<li><strong>参数格式</strong>：接口需要传递的参数，每个参数必须包含<strong>参数名称</strong>、<strong>参数类型</strong>、<strong>是否必选</strong>、<strong>参数说明</strong>这4项内容。</li>
<li><strong>响应格式</strong>：接口的返回值的详细描述，一般包括<strong>数据名称</strong>、<strong>数据类型</strong>、<strong>说明</strong>3项内容。</li>
<li>返回示例（可选）：通过对象的形式，列举服务器返回数据的结构。</li>
</ol>
<h3 id="3接口文档示例">3.接口文档示例</h3>
<figure data-type="image" tabindex="11"><img src="https://shumild.github.io/post-images/1642952299072.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://shumild.github.io/post-images/1642952315461.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://shumild.github.io/post/hello-gridea/</id>
        <link href="https://shumild.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>