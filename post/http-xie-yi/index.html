<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HTTP协议 | shumild</title>
<link rel="shortcut icon" href="https://shumild.github.io/favicon.ico?v=1643982253384">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://shumild.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="HTTP协议 | shumild - Atom Feed" href="https://shumild.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="HTTP 协议
什么是通信
通信，就是信息的传递和交换。
通信三要素：


通信的主体


通信的内容


通信的方式


现实生活中的通信
案例：张三要把自己考上大学的好消息写信告诉自己的好朋友李四。
其中：
​			通信的主体是张三和李..." />
    <meta name="keywords" content="计算机网络,Ajax" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://shumild.github.io">
  <img class="avatar" src="https://shumild.github.io/images/avatar.png?v=1643982253384" alt="">
  </a>

  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://shumild.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/shumild" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://leetcode-cn.com/u/shumild/" target="_blank">
          <i class="ri-leetcode-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

<script>
  let x = document.getElementsByClassName("ri-leetcode-line");
  x[0].innerHTML = '<img src="https://leetcode-cn.com/favicon.ico" class="leetcodeImg" >'
</script>
        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              HTTP协议
            </h2>
            <div class="post-info">
              <span>
                2022-01-22
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://shumild.github.io/ji-suan-ji-wang-luo/" class="post-tag">
                  # 计算机网络
                </a>
              
                <a href="https://shumild.github.io/VOCNubqIS/" class="post-tag">
                  # Ajax
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="http-协议">HTTP 协议</h1>
<h2 id="什么是通信">什么是通信</h2>
<p>通信，就是<strong>信息的传递和交换</strong>。</p>
<p>通信三要素：</p>
<ul>
<li>
<p>通信的主体</p>
</li>
<li>
<p>通信的内容</p>
</li>
<li>
<p>通信的方式</p>
</li>
</ul>
<h3 id="现实生活中的通信">现实生活中的通信</h3>
<p>案例：<strong>张三</strong>要把自己考上大学的好消息<strong>写信</strong>告诉自己的好朋友<strong>李四</strong>。</p>
<p>其中：</p>
<p>​			通信的<strong>主体</strong>是张三和李四。</p>
<p>​			通信的<strong>内容</strong>是考上大学。</p>
<p>​			通信的<strong>方式</strong>是<strong>写信</strong>。</p>
<h3 id="互联网中的通信">互联网中的通信</h3>
<p>案例：<strong>服务器</strong>把大学的简介通过<strong>响应</strong>的方式发送给<strong>客户端浏览器</strong>。</p>
<p>其中：</p>
<p>​			通信的<strong>主体</strong>是服务器和客户端浏览器。</p>
<p>​			通信的<strong>内容</strong>是大学的简介。</p>
<p>​			通信的<strong>方式</strong>是<strong>响应</strong>。</p>
<h2 id="什么是通信协议">什么是通信协议</h2>
<p><strong>通信协议</strong>（Communication Protocol）是指通信的双方完成通信所<strong>必须遵守</strong>的<strong>规则和约定</strong>。</p>
<p>通俗的理解：通信双方<strong>采用约定好的格式</strong>来发送和接收消息，这种<strong>事先约定好的通信格式</strong>，就叫做通信协议。</p>
<h3 id="生活中的通信协议">生活中的通信协议</h3>
<p><strong>张三</strong>与李四采用<strong>写信</strong>的方式进行通信，在填写信封时，写信的双方需要<strong>遵守固定的规则</strong>。<strong>信封的填写规则</strong>就是一种通信协议。</p>
<figure data-type="image" tabindex="1"><img src="https://shumild.github.io/post-images/1643808606596.png" alt="" loading="lazy"></figure>
<h3 id="互联网中的通信协议">互联网中的通信协议</h3>
<p>客户端与服务器之间要实现<strong>网页内容</strong>的传输，则通信的双方必须遵守<strong>网页内容的传输协议</strong>。</p>
<p><strong>网页内容</strong>又叫做<strong>超文本</strong>，因此<strong>网页内容的传输协议</strong>又叫做<strong>超文本传输协议</strong>（HyperText Transfer Protocol），简称 <strong>HTTP</strong> <strong>协议</strong>。</p>
<h2 id="http">HTTP</h2>
<h3 id="什么是-http-协议">什么是 HTTP 协议</h3>
<p><strong>HTTP</strong> <strong>协议</strong>即超文本传送协议 (<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。</p>
<p>例如：</p>
<ul>
<li>
<p><strong>客户端</strong>要以HTTP协议要求的格式把数据<strong>提交</strong>到<strong>服务器</strong></p>
</li>
<li>
<p><strong>服务器</strong>要以HTTP协议要求的格式把内容<strong>响应</strong>给<strong>客户端</strong></p>
</li>
</ul>
<h3 id="http-协议的交互模型">HTTP 协议的交互模型</h3>
<p>HTTP 协议采用了 <strong>请求/响应</strong> 的交互模型。</p>
<figure data-type="image" tabindex="2"><img src="https://shumild.github.io/post-images/1643808586191.png" alt="" loading="lazy"></figure>
<h1 id="http-请求消息">HTTP 请求消息</h1>
<h2 id="什么是-http-请求消息">什么是 HTTP 请求消息</h2>
<p>由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，<strong>客户端发起</strong>的请求叫做 <strong>HTTP</strong> <strong>请求</strong>，<strong>客户端发送到服务器</strong>的消息，叫做 <strong>HTTP</strong> <strong>请求消息</strong>。</p>
<blockquote>
<p><strong>注意</strong>：HTTP <strong>请求消息</strong>又叫做 HTTP <strong>请求报文</strong>。</p>
</blockquote>
<h2 id="http-请求消息的组成部分">HTTP 请求消息的组成部分</h2>
<p>HTTP 请求消息由<strong>请求行</strong>（request line）、<strong>请求头部</strong>（ header ） 、<strong>空行</strong> 和 <strong>请求体</strong> 4 个部分组成。</p>
<figure data-type="image" tabindex="3"><img src="https://shumild.github.io/post-images/1643808560103.png" alt="" loading="lazy"></figure>
<h3 id="请求行">请求行</h3>
<p><strong>请求行</strong>由<strong>请求方式</strong>、<strong>URL</strong> 和 <strong>HTTP 协议版本</strong> 3 个部分组成，他们之间使用空格隔开。</p>
<figure data-type="image" tabindex="4"><img src="https://shumild.github.io/post-images/1643808543515.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://shumild.github.io/post-images/1643808529261.png" alt="" loading="lazy"></figure>
<h3 id="请求头部">请求头部</h3>
<p><strong>请求头部</strong>用来描述<strong>客户端的基本信息</strong>，从而把<strong>客户端相关的信息</strong>告知服务器。比如：<strong>User-Agent</strong> 用来说明当前是什么类型的浏览器；<strong>Content-Type</strong> 用来描述发送到服务器的数据格式；<strong>Accept</strong> 用来描述客户端能够接收什么类型的返回内容；<strong>Accept-Language</strong> 用来描述客户端期望接收哪种人类语言的文本内容。</p>
<p>请求头部由多行 <strong>键/值对</strong> 组成，每行的键和值之间用英文的冒号分隔。</p>
<figure data-type="image" tabindex="6"><img src="https://shumild.github.io/post-images/1643808510800.png" alt="" loading="lazy"></figure>
<h4 id="常见的请求头字段">常见的请求头字段</h4>
<table>
<thead>
<tr>
<th><strong>头部字段</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>要请求的服务器域名</td>
</tr>
<tr>
<td>Connection</td>
<td>客户端与服务器的连接方式(close  或  keepalive)</td>
</tr>
<tr>
<td>Content-Length</td>
<td>用来描述请求体的大小</td>
</tr>
<tr>
<td>Accept</td>
<td>客户端可识别的响应内容类型列表</td>
</tr>
<tr>
<td>User-Agent</td>
<td>产生请求的浏览器类型</td>
</tr>
<tr>
<td>Content-Type</td>
<td>客户端告诉服务器实际发送的数据类型</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>客户端可接收的内容压缩编码形式</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>用户期望获得的自然语言的优先顺序</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="7"><img src="https://shumild.github.io/post-images/1643808494359.png" alt="" loading="lazy"></figure>
<p>关于更多请求头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</p>
<h3 id="空行">空行</h3>
<p>最后一个请求头字段的后面是一个<strong>空行</strong>，通知服务器<strong>请求头部至此结束</strong>。</p>
<p>请求消息中的空行，用来分隔<strong>请求头部</strong>与<strong>请求体</strong>。</p>
<figure data-type="image" tabindex="8"><img src="https://shumild.github.io/post-images/1643808478328.png" alt="" loading="lazy"></figure>
<h3 id="请求体">请求体</h3>
<p>请求体中存放的，是要通过 <strong>POST 方式</strong>提交到服务器的数据。</p>
<figure data-type="image" tabindex="9"><img src="https://shumild.github.io/post-images/1643808462716.png" alt="" loading="lazy"></figure>
<blockquote>
<p><strong>注意</strong>：只有 POST 请求才有请求体，GET 请求没有请求体！</p>
</blockquote>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="10"><img src="https://shumild.github.io/post-images/1643808447957.png" alt="" loading="lazy"></figure>
<h1 id="http-响应消息">HTTP 响应消息</h1>
<h2 id="什么是-http-响应消息">什么是 HTTP 响应消息</h2>
<p><strong>响应消息</strong>就是<strong>服务器响应给客户端</strong>的消息内容，也叫作响应报文。</p>
<h2 id="http-响应消息的组成部分">HTTP 响应消息的组成部分</h2>
<p>HTTP响应消息由<strong>状态行</strong>、<strong>响应头部</strong>、<strong>空行</strong> 和 <strong>响应体</strong> 4 个部分组成，如下图所示：</p>
<figure data-type="image" tabindex="11"><img src="https://shumild.github.io/post-images/1643808430624.png" alt="" loading="lazy"></figure>
<h3 id="状态行">状态行</h3>
<p><strong>状态行</strong>由 <strong>HTTP 协议版本</strong>、<strong>状态码</strong>和<strong>状态码的描述文本</strong> 3 个部分组成，他们之间使用空格隔开。</p>
<figure data-type="image" tabindex="12"><img src="https://shumild.github.io/post-images/1643808408835.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://shumild.github.io/post-images/1643808394273.png" alt="" loading="lazy"></figure>
<h3 id="响应头部">响应头部</h3>
<p><strong>响应头部</strong>用来描述<strong>服务器的基本信息</strong>。响应头部由多行 <strong>键/值对</strong> 组成，每行的键和值之间用英文的冒号分隔。</p>
<figure data-type="image" tabindex="14"><img src="https://shumild.github.io/post-images/1643808374980.png" alt="" loading="lazy"></figure>
<h4 id="常见的响应头字段">常见的响应头字段</h4>
<figure data-type="image" tabindex="15"><img src="https://shumild.github.io/post-images/1643808361441.png" alt="" loading="lazy"></figure>
<p>关于更多响应头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</p>
<h3 id="空行-2">空行</h3>
<p>在最后一个响应头部字段结束之后，会紧跟一个<strong>空行</strong>，用来通知客户端<strong>响应头部至此结束</strong>。</p>
<p>响应消息中的空行，用来分隔<strong>响应头部</strong>与<strong>响应体</strong>。</p>
<figure data-type="image" tabindex="16"><img src="https://shumild.github.io/post-images/1643808344889.png" alt="" loading="lazy"></figure>
<h3 id="响应体">响应体</h3>
<p>响应体中存放的，是服务器响应给客户端的资源内容。</p>
<p><img src="https://shumild.github.io/post-images/1643808327233.png" alt="" loading="lazy">)</p>
<figure data-type="image" tabindex="17"><img src="https://shumild.github.io/post-images/1643808295895.png" alt="" loading="lazy"></figure>
<h3 id="总结-2">总结</h3>
<figure data-type="image" tabindex="18"><img src="https://shumild.github.io/post-images/1643808270515.png" alt="" loading="lazy"></figure>
<h1 id="http-请求方法">HTTP 请求方法</h1>
<h2 id="什么是-http-请求方法">什么是 HTTP 请求方法</h2>
<p>HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明<strong>要对服务器上的资源执行的操作</strong>。最常用的请求方法是 GET 和 POST。</p>
<h2 id="http-的请求方法">HTTP 的请求方法</h2>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>GET</strong></td>
<td>(<strong>查询</strong>)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。</td>
</tr>
<tr>
<td>2</td>
<td><strong>POST</strong></td>
<td>(<strong>新增</strong>)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。</td>
</tr>
<tr>
<td>3</td>
<td><strong>PUT</strong></td>
<td>(<strong>修改</strong>)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。</td>
</tr>
<tr>
<td>4</td>
<td><strong>DELETE</strong></td>
<td>(<strong>删除</strong>)请求服务器删除指定的资源。</td>
</tr>
<tr>
<td>5</td>
<td>HEAD</td>
<td>HEAD  方法请求一个与 GET 请求的响应相同的响应，但没有响应体。</td>
</tr>
<tr>
<td>6</td>
<td>OPTIONS</td>
<td>获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</td>
</tr>
<tr>
<td>7</td>
<td>CONNECT</td>
<td>建立一个到由目标资源标识的服务器的隧道。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。</td>
</tr>
<tr>
<td>9</td>
<td>PATCH</td>
<td>是对  PUT 方法的补充，用来对已知资源进行局部更新。</td>
</tr>
</tbody>
</table>
<h1 id="http-响应状态码">HTTP 响应状态码</h1>
<h2 id="什么是-http-响应状态码">什么是 HTTP 响应状态码</h2>
<p><strong>HTTP</strong> <strong>响应状态码</strong>（HTTP Status Code），也属于 HTTP 协议的一部分，<strong>用来标识响应的状态</strong>。</p>
<p>响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。</p>
<figure data-type="image" tabindex="19"><img src="https://shumild.github.io/post-images/1643808252843.png" alt="" loading="lazy"></figure>
<h2 id="http-响应状态码的组成及分类">HTTP 响应状态码的组成及分类</h2>
<p>HTTP 状态码由<strong>三个十进制数字</strong>组成，<strong>第一个十进制数字</strong>定义了<strong>状态码的类型</strong>，后两个数字用来对状态码进行细分。</p>
<p>HTTP 状态码共分为 5 种类型：</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>分类描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1**</td>
<td><strong>信息</strong>，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到  1**  类型的状态码）</td>
</tr>
<tr>
<td>2**</td>
<td><strong>成功</strong>，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td><strong>重定向</strong>，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td><strong>客户端错误</strong>，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td><strong>服务器错误</strong>，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p>完整的 HTTP 响应状态码，可以参考 MDN 官方文档 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</p>
<h3 id="2-成功相关的响应状态码">2** 成功相关的响应状态码</h3>
<p>2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于  GET 与 POST  请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源，通常用于  POST 或 PUT  请求</td>
</tr>
</tbody>
</table>
<h3 id="3-重定向相关的响应状态码">3** 重定向相关的响应状态码</h3>
<p>3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>301</td>
<td>Moved  Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替  。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。</td>
</tr>
<tr>
<td>304</td>
<td>Not  Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td>
</tr>
</tbody>
</table>
<h3 id="4-客户端错误相关的响应状态码">4** 客户端错误相关的响应状态码</h3>
<p>4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>Bad  Request</td>
<td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>当前请求需要用户验证。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器已经理解请求，但是拒绝执行它。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
<tr>
<td>408</td>
<td>Request  Timeout</td>
<td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td>
</tr>
</tbody>
</table>
<h3 id="5-服务器错误相关的响应状态码">5** 服务器错误相关的响应状态码</h3>
<p>5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的 5** 类型的状态码如下：</p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>状态码英文名称</strong></th>
<th><strong>中文描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>Internal  Server Error</td>
<td>服务器内部错误，无法完成请求。</td>
</tr>
<tr>
<td>501</td>
<td>Not  Implemented</td>
<td>服务器不支持该请求方法，无法完成请求。只有  GET 和 HEAD  请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501。</td>
</tr>
<tr>
<td>503</td>
<td>Service  Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#http-%E5%8D%8F%E8%AE%AE">HTTP 协议</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E4%BF%A1">什么是通信</a>
<ul>
<li><a href="#%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1">现实生活中的通信</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1">互联网中的通信</a></li>
</ul>
</li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">什么是通信协议</a>
<ul>
<li><a href="#%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">生活中的通信协议</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">互联网中的通信协议</a></li>
</ul>
</li>
<li><a href="#http">HTTP</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-http-%E5%8D%8F%E8%AE%AE">什么是 HTTP 协议</a></li>
<li><a href="#http-%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B">HTTP 协议的交互模型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http-%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF">HTTP 请求消息</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-http-%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF">什么是 HTTP 请求消息</a></li>
<li><a href="#http-%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">HTTP 请求消息的组成部分</a>
<ul>
<li><a href="#%E8%AF%B7%E6%B1%82%E8%A1%8C">请求行</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8">请求头部</a>
<ul>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%AD%97%E6%AE%B5">常见的请求头字段</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E8%A1%8C">空行</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E4%BD%93">请求体</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http-%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF">HTTP 响应消息</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-http-%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF">什么是 HTTP 响应消息</a></li>
<li><a href="#http-%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">HTTP 响应消息的组成部分</a>
<ul>
<li><a href="#%E7%8A%B6%E6%80%81%E8%A1%8C">状态行</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8">响应头部</a>
<ul>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4%E5%AD%97%E6%AE%B5">常见的响应头字段</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E8%A1%8C-2">空行</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E4%BD%93">响应体</a></li>
<li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">HTTP 请求方法</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-http-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">什么是 HTTP 请求方法</a></li>
<li><a href="#http-%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">HTTP 的请求方法</a></li>
</ul>
</li>
<li><a href="#http-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 响应状态码</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-http-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">什么是 HTTP 响应状态码</a></li>
<li><a href="#http-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E7%BB%84%E6%88%90%E5%8F%8A%E5%88%86%E7%B1%BB">HTTP 响应状态码的组成及分类</a>
<ul>
<li><a href="#2-%E6%88%90%E5%8A%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">2** 成功相关的响应状态码</a></li>
<li><a href="#3-%E9%87%8D%E5%AE%9A%E5%90%91%E7%9B%B8%E5%85%B3%E7%9A%84%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">3** 重定向相关的响应状态码</a></li>
<li><a href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">4** 客户端错误相关的响应状态码</a></li>
<li><a href="#5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81">5** 服务器错误相关的响应状态码</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://shumild.github.io/post/kua-yu-he-jsonp/">
              <h3 class="post-title">
                跨域和JSONP
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">shumild</a>
  <a class="rss" href="https://shumild.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
